<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml"
		   xmlns:components="components.*"
		   width="100%" height="{rowHeight}" initialize="init()" creationComplete="{onCreationComplete();}" verticalScrollPolicy="off">
	<mx:Style source="/assets/adventure.css"/>
	<mx:Style>
		.miniBox {
			borderStyle: "solid";
			borderThickness: "1";
		}
	</mx:Style>
	<mx:Script>
		<![CDATA[
			import assets.DottedBorder;
			import components.bubbles.AdventureBubble;
			import components.bubbles.DestinationBubble;
			import screens.PopupMc;
			import screens.PopupShortAnswer;
			import tree.DisplayNode;
			import tree.DisplayTree;
			import tree.Node;
			//------------------------------------------------------------------
			//
			//  Public Fields
			//
			//------------------------------------------------------------------
			public static const DEFAULT_ANS_TEXT:String = "Enter possible answer here.";
			public static const DEFAULT_FEEDBACK_TEXT:String = "Enter optional feedback here.";
			private static const NODE_BOX_RADIUS:Number = 22;
			[Bindable]
			public static var rowHeight:Number = 56;
			[Bindable]
			public var letter:String = "";
			/**
			 * The node we're coming from
			 */
			[Bindable]
			public var node:Node;
			[Bindable]
			public var rowIndex:int = 0;
			public var isDefault:Boolean = false;
			[Bindable]
			private var _popupInstance:PopupMc;
			private var _pendingText:String = "";
			/**
			 * Function to call if we try to link a node that doesn't exist
			 */
			public var missingNodeCallback:Function;
			//------------------------------------------------------------------
			//
			//  Private Fields
			//
			//------------------------------------------------------------------
			[Bindable]
			/**
			 * The node we're going to
			 */
			private var _destination:Node;
			// private var _feedbackField:TextArea;
			private var _feedbackText:String;
			private var _creationIsComplete:Boolean = false;
			//------------------------------------------------------------------
			//
			//  Accessor Methods
			//
			//------------------------------------------------------------------
			public function get text():String
			{
				if(!_creationIsComplete) return _pendingText;
				if(answerField.parent != null) return answerField.text;
				else return shortAnswerField.text;
			}
			public function set text(val:String):void
			{
				if(!_creationIsComplete) _pendingText = val;
				else if(answerField.parent != null) answerField.text = val;
				else shortAnswerField.text = val;
			}
			public function get popupInstance():PopupMc { return _popupInstance; }
			public function set popupInstance(val:PopupMc):void
			{
				_popupInstance = val;
				updateAnswerFields();
			}
			public function get destination():Node { return _destination; }
			public function set destination(val:Node):void
			{
				_destination = val;
				updateDestinationBox();
			}
			public function get feedback():String { return _feedbackField.text == DEFAULT_FEEDBACK_TEXT ? null : _feedbackField.text }
			public function set feedback(value:String):void
			{
				_feedbackText = value;
				if(_creationIsComplete) initFeedback();
			}
			//------------------------------------------------------------------
			//
			//  Member Functions
			//
			//------------------------------------------------------------------
			private function init():void
			{
				destCanvas.addEventListener(DestinationBubble.EVENT_DESTINATION_CHOICE, onDestChange, false, 0, true);
			}
			public function destroy():void
			{
				// if(scoreBox != null) scoreBox.destroy();
				shortAnswerField.destroy();
			}
			private function onCreationComplete():void
			{
				updateAnswerColor();
				updateDestinationBox();
				updateAnswerFields();
				answerField.restrict = "A-Za-z0-9_~!@#$%\\^\\-&*()_+{}|[];\'\`,./<>?:\\\\\"=\ ";
				_creationIsComplete = true;
				initFeedback();

				// Since Destination mode is default, this is set statically
				//scoreBox.parent.removeChild(scoreBox);
				//scoreBox = null;

				if(_pendingText.length)
				{
					this.text = _pendingText;
					_pendingText = "";
				}
			}

			private function initFeedback():void
			{
				if(_feedbackText != null && _feedbackText.length)
				{
					_feedbackField.text = _feedbackText;
				}
				updateFeedbackColor();
			}

			private function updateDestinationBox():void
			{
				if(destCanvas != null) destCanvas.setTargetNode(_destination, NODE_BOX_RADIUS);
			}
			private function updateAnswerFields():void
			{
				if(_popupInstance == null ||
				   answerField == null || shortAnswerField == null ||
				   answerField.parent == null || shortAnswerField.parent == null)
					return;
				// remove the field that doesn't belong
				if(_popupInstance is PopupShortAnswer && !isDefault) mainHBox.removeChild(answerField);
				else mainHBox.removeChild(shortAnswerField);
			}
			private function onMouseWheel(event:MouseEvent):void
			{
				var mainField:TextArea = event.currentTarget as TextArea;
				if(mainField == null) return;
				//If scrolling down
				if(event.delta < 0)
				{
					if(mainField.verticalScrollPosition == mainField.maxVerticalScrollPosition)
					{
						dispatchEvent(event);
					}
				}
					//If scrolling up
				else if(event.delta > 0)
				{
					if(mainField.verticalScrollPosition == 0)
					{
						dispatchEvent(event);
					}
				}
			}
			private function onDestChange(e:DataEvent):void
			{
				var result:int = int(e.data);
				// If the target node didn't exist (was in warning state), create it first
				if(destination == null)
				{
					// create the missing node
					destination = displayTree.addNode(node, null).node;
					node.data.addAnswer("", "0");
					// call the desired callback
					if(missingNodeCallback != null) missingNodeCallback.apply(this, [node]);
				}
				var targetIndex:Number = rowIndex + popupInstance.rowOffset;
				// Determine what to do with links
				switch(result) {
					// make target node point back to "this" node
					case DestinationBubble.THIS_NODE:
						displayTree.setLink(node.children[targetIndex], node);
						popupInstance.onDoneEditingLink();
						break;
					// make the target node a concrete node (doesn't point anywhere)
					case DestinationBubble.NEW_NODE:
						displayTree.setLink(node.children[targetIndex], node.children[targetIndex]);
						popupInstance.onDoneEditingLink();
						break;
					// make the target node point to another node (brings up link-editor)
					case DestinationBubble.EXISTING_NODE:
						dispatchEvent(new DataEvent(DisplayNode.EVENT_FIND_LINK, true, false, String(node.children[targetIndex].id)));
						break;
				}
			}

			private function get displayTree():DisplayTree
			{
				return node.displayNode.displayTree;
			}

			private function updateAnswerColor():void
			{
				answerField.setStyle("color", answerField.text == DEFAULT_ANS_TEXT ? "#a5a5a5" : "#505050");
			}

			private function updateFeedbackColor():void
			{
				_feedbackField.setStyle("color", _feedbackField.text == DEFAULT_FEEDBACK_TEXT ? "#a5a5a5" : "#505050");
			}
		]]>
	</mx:Script>
	<mx:HBox id="mainHBox" borderStyle="solid" borderSides="bottom" borderThickness="1" borderColor="#CCCCCC" width="100%" height="100%" horizontalGap="0">
		<!-- Answer -->
		<mx:TextArea maxChars="{Creator.ANSWER_CHAR_LIMIT}" id="answerField" styleName="darkText" fontSize="18" width="100%" height="100%" mouseWheel="onMouseWheel(event)" text="{DEFAULT_ANS_TEXT}" focusIn="{
								 	if(answerField.text == DEFAULT_ANS_TEXT) {
								 		answerField.text = '';
								 		updateAnswerColor();
								 	}
								 }"
								 focusOut="{
								 	if(!answerField.text.length) {
								 		answerField.text = DEFAULT_ANS_TEXT;
								 		updateAnswerColor();
								 	}
								 }"
		/>
		<components:ShortAnswerAreaNew id="shortAnswerField" borderSkin="assets.DottedBorder" styleName="darkText" fontSize="18" width="100%" height="100%" mouseWheel="onMouseWheel(event)"/>
		<!-- Feedback -->
		<mx:HBox id="feedbackCanvasContainer" width="350" height="100%" horizontalGap="0" backgroundColor="#ffffff">
			<mx:TextArea maxChars="{Creator.ANSWER_CHAR_LIMIT}" id="_feedbackField" styleName="darkTextLight" width="280" height="100%" fontSize="14" text="{DEFAULT_FEEDBACK_TEXT}" borderSkin="assets.DottedBorder" focusIn="{
								 	if(_feedbackField.text == DEFAULT_FEEDBACK_TEXT) {
								 		_feedbackField.text = '';
								 		updateFeedbackColor();
								 	}
								 }"
								 focusOut="{
								 	if(!_feedbackField.text.length) {
								 		_feedbackField.text = DEFAULT_FEEDBACK_TEXT;
								 		updateFeedbackColor();
								 	}
								 }" />
			<components:DestinationBox id="destCanvas"
									   styleName="miniBox"
									   width="70" height="100%"
									   borderSkin="assets.DottedBorder"
									   borderSides="left" />
		</mx:HBox>
	</mx:HBox>
</mx:Canvas>