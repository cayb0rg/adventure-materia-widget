<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml"
		   xmlns:components="components.*"
		   width="100%" height="{rowHeight}" initialize="init()" creationComplete="{onCreationComplete();}" verticalScrollPolicy="off">
	<mx:Style source="/assets/adventure.css"/>
	<mx:Style>
		.miniBox {
			borderStyle: "solid";
			borderThickness: "1";
		}
	</mx:Style>
	<mx:Script>
		<![CDATA[
			import assets.DottedBorder;
			import components.bubbles.AdventureBubble;
			import components.bubbles.DestinationBubble;
			import screens.PopupMc;
			import screens.PopupShortAnswer;
			import tree.DisplayNode;
			import tree.DisplayTree;
			import tree.Node;
			//------------------------------------------------------------------
			//
			//  Public Fields
			//
			//------------------------------------------------------------------
			private static const NODE_BOX_RADIUS:Number = 22;
			[Bindable]
			public static var rowHeight:Number = 56;
			[Bindable]
			public var letter:String = "";
			/**
			 * The node we're coming from
			 */
			[Bindable]
			public var node:Node;
			[Bindable]
			public var rowIndex:int = 0;
			public var isDefault:Boolean = false;
			[Bindable]
			private var _popupInstance:PopupMc;
			private var _pendingText:String = "";
			/**
			 * Function to call if we try to link a node that doesn't exist
			 */
			public var missingNodeCallback:Function;
			//------------------------------------------------------------------
			//
			//  Private Fields
			//
			//------------------------------------------------------------------
			[Bindable]
			/**
			 * The node we're going to
			 */
			private var _destination:Node;
			private var _feedbackField:TextArea;
			private var _feedbackText:String;
			private var _creationIsComplete:Boolean = false;
			//------------------------------------------------------------------
			//
			//  Accessor Methods
			//
			//------------------------------------------------------------------
			public function get text():String
			{
				if(!_creationIsComplete) return _pendingText;
				if(answerField.parent != null) return answerField.text;
				else return shortAnswerField.text;
			}
			public function set text(val:String):void
			{
				if(!_creationIsComplete) _pendingText = val;
				else if(answerField.parent != null) answerField.text = val;
				else shortAnswerField.text = val;
			}
			public function get popupInstance():PopupMc { return _popupInstance; }
			public function set popupInstance(val:PopupMc):void
			{
				_popupInstance = val;
				updateAnswerFields();
			}
			public function get destination():Node { return _destination; }
			public function set destination(val:Node):void
			{
				_destination = val;
				updateDestinationBox();
			}
			public function get feedback():String { return _feedbackField == null ? null : _feedbackField.text }
			public function set feedback(value:String):void
			{
				_feedbackText = value;
				if(_creationIsComplete) initFeedback();
			}
			//------------------------------------------------------------------
			//
			//  Member Functions
			//
			//------------------------------------------------------------------
			private function init():void
			{
				trace("init");
				destCanvas.addEventListener(DestinationBubble.EVENT_DESTINATION_CHOICE, onDestChange, false, 0, true);
			}
			public function destroy():void
			{
				// if(scoreBox != null) scoreBox.destroy();
				shortAnswerField.destroy();
			}
			private function onCreationComplete():void
			{
				updateDestinationBox();
				updateAnswerFields();
				answerField.restrict = "^\u0001-\u0008\u000B-\u001F";
				shortAnswerField.restrict = "^\u0001-\u0008\u000B-\u001F";
				_creationIsComplete = true;
				initFeedback();

				// Since Destination mode is default, this is set statically
				//scoreBox.parent.removeChild(scoreBox);
				//scoreBox = null;

				if(_pendingText.length)
				{
					this.text = _pendingText;
					_pendingText = "";
				}
			}
			private function initFeedback():void
			{
				if(_feedbackText != null && _feedbackText.length)
				{
					expandFeedback();
					_feedbackField.text = _feedbackText;
				}
				else if(_feedbackField != null && _feedbackField.parent != null)
				{
					feedbackCanvas.width = 160;
					feedbackCanvas.removeChild(_feedbackField);
					feedbackCanvas.addChildAt(feedbackButton, 0);
				}
			}
			private function updateDestinationBox():void
			{
				if(destCanvas != null) destCanvas.setTargetNode(_destination, NODE_BOX_RADIUS);
			}
			private function updateAnswerFields():void
			{
				if(_popupInstance == null ||
				   answerField == null || shortAnswerField == null ||
				   answerField.parent == null || shortAnswerField.parent == null)
					return;
				// remove the field that doesn't belong
				if(_popupInstance is PopupShortAnswer && !isDefault) mainHBox.removeChild(answerField);
				else mainHBox.removeChild(shortAnswerField);
			}
			private function onMouseWheel(event:MouseEvent):void
			{
				var mainField:TextArea = event.currentTarget as TextArea;
				if(mainField == null) return;
				trace(event.delta, mainField.verticalScrollPosition, mainField.maxVerticalScrollPosition);
				//If scrolling down
				if(event.delta < 0)
				{
					if(mainField.verticalScrollPosition == mainField.maxVerticalScrollPosition)
					{
						dispatchEvent(event);
					}
				}
					//If scrolling up
				else if(event.delta > 0)
				{
					if(mainField.verticalScrollPosition == 0)
					{
						dispatchEvent(event);
					}
				}
			}
			private function onDestChange(e:DataEvent):void
			{
				trace("onDestChange " + e.data + "  " + int(e.data));
				var result:int = int(e.data);
				// If the target node didn't exist (was in warning state), create it first
				if(destination == null)
				{
					// create the missing node
					destination = displayTree.addNode(node, null).node;
					node.data.addAnswer("", "0");
					// call the desired callback
					if(missingNodeCallback != null) missingNodeCallback.apply(this, [node]);
				}
				var targetIndex:Number = rowIndex + popupInstance.rowOffset;
				// Determine what to do with links
				switch(result) {
					// make target node point back to "this" node
					case DestinationBubble.THIS_NODE:
						trace("this one");
						displayTree.setLink(node.children[targetIndex], node);
						popupInstance.onDoneEditingLink();
						break;
					// make the target node a concrete node (doesn't point anywhere)
					case DestinationBubble.NEW_NODE:
						trace("New");
						displayTree.setLink(node.children[targetIndex], node.children[targetIndex]);
						popupInstance.onDoneEditingLink();
						break;
					// make the target node point to another node (brings up link-editor)
					case DestinationBubble.EXISTING_NODE:
						trace("Existing");
						dispatchEvent(new DataEvent(DisplayNode.EVENT_FIND_LINK, true, false, String(node.children[targetIndex].id)));
						break;
				}
			}
			private function expandFeedback(focus:Boolean = false):void
			{
				feedbackCanvas.width = 280;
				//feedbackStack.selectedChild = feedbackFieldContainer;
				_feedbackField = new TextArea();
				_feedbackField.id = "_feedbackField";
				_feedbackField.styleName = "darkText";
				_feedbackField.setStyle("fontSize", 16);
				_feedbackField.setStyle("borderSides", "");
				_feedbackField.setStyle("borderSkin", DottedBorder);
				_feedbackField.width = feedbackCanvas.width;
				_feedbackField.height = feedbackCanvas.height;
				_feedbackField.addEventListener(MouseEvent.MOUSE_WHEEL, onMouseWheel, false, 0, true);
				_feedbackField.addEventListener(FocusEvent.FOCUS_OUT, onFeedbackFocusOut, false, 0, true);
				feedbackCanvas.removeChildAt(0);
				feedbackCanvas.addChild(_feedbackField);
				if(focus) _feedbackField.setFocus();
			}
			private function onFeedbackFocusOut(e:Event):void
			{
				if(_feedbackField.text.length == 0)
				{
					contractFeedback();
				}
			}
			private function contractFeedback():void
			{
				if(_feedbackField == null) return;
				feedbackCanvas.width = 160;
				_feedbackField.removeEventListener(MouseEvent.MOUSE_WHEEL, onMouseWheel);
				_feedbackField.removeEventListener(FocusEvent.FOCUS_OUT, onFeedbackFocusOut);
				feedbackCanvas.removeChild(_feedbackField);
				feedbackCanvas.addChild(feedbackButton);
			}
			private function get displayTree():DisplayTree
			{
				return node.displayNode.displayTree;
			}
		]]>
	</mx:Script>
	<mx:HBox id="mainHBox" borderStyle="solid" borderSides="bottom" borderThickness="1" borderColor="#CCCCCC" width="100%" height="100%" horizontalGap="0">
		<!-- Answer -->
		<mx:TextArea id="answerField" borderSkin="assets.DottedBorder" styleName="darkText" fontSize="18" width="100%" height="100%" mouseWheel="onMouseWheel(event)"/>
		<components:ShortAnswerArea id="shortAnswerField" borderSkin="assets.DottedBorder" styleName="darkText" fontSize="18" width="100%" height="100%" mouseWheel="onMouseWheel(event)"/>
		<!-- Feedback -->
		<mx:Canvas borderSkin="assets.DottedBorder" borderSides="left"
				   id="feedbackCanvas" width="160" height="100%">
			<components:AdventureButton id="feedbackButton" label="Add&#13;Feedback"
					   width="112" height="40" usePlus="true"
					   x="{(feedbackCanvas.width-feedbackButton.width)/2}"
					   y="{(feedbackCanvas.height-feedbackButton.height)/2}"
					   click="expandFeedback(true);"/>
		</mx:Canvas>
		<!-- Destination Node -->
		<components:DestinationBox id="destCanvas"
								   styleName="miniBox"
								   width="70" height="100%"
								   borderSkin="assets.DottedBorder"
								   borderSides="left" />
	</mx:HBox>
</mx:Canvas>