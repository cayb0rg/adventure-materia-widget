<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" >
<mx:Canvas id="bitmapHolder" top="1" bottom="1" left="1" right="1" clipContent="true" horizontalScrollPolicy="off" verticalScrollPolicy="off" >
	<mx:UIComponent id="graphicsLayer"
					width="{RADIUS_DEFAULT * 2}"
					height="{RADIUS_DEFAULT * 2}"
					verticalCenter="0" horizontalCenter="0"
					mouseOver="{onGraphicMouseOver()}"
					mouseOut="{onGraphicMouseOut()}"
					mouseDown="{onMouseDown()}"
					click="{onClick()}"
					/>
</mx:Canvas>
<mx:Script>
	<![CDATA[
		import components.bubbles.AdventureBubble;
		import components.bubbles.DestinationBubble;
		import tree.DisplayNode;
		import tree.Node;
		import nm.ui.ToolTip;
		[Embed (source="../assets/warning-large.png")]
		public static const IMAGE_WARNING:Class;
		public static const RADIUS_DEFAULT:Number = 30;
		private static const FILTER_STROKE:Number = 2;
		private static const FILTERSET_NORMAL:Array = [];
		private static const FILTERSET_HIGHLIGHT:Array = [new GlowFilter(0, .5, FILTER_STROKE, FILTER_STROKE)];
		public var bubble:DestinationBubble;
		public var bubbleDirection:int = AdventureBubble.DIRECTION_UP;
		private var helperDisplayNode:DisplayNode;
		private var nodeBitmap:BitmapData
		private var _targetRadius:Number;
		private var _interactive:Boolean;
		private var _suspendNextBubble:Boolean = false;
		public function setTargetNode(node:Node, radius:Number = RADIUS_DEFAULT, interactive:Boolean = true):void
		{
			_interactive = interactive;
			// Set target node for our dummy display node
			if(helperDisplayNode == null) helperDisplayNode = new DisplayNode(null);
			helperDisplayNode.allowFlags = false;
			helperDisplayNode.node = node;
			_redraw(radius);
		}
		public function redraw():void
		{
			_redraw(_targetRadius);
		}
		private function _redraw(radius:Number = RADIUS_DEFAULT):void
		{
			// Keep trak of radius
			_targetRadius = radius;
			if(helperDisplayNode.node == null)
			{
				// Create an invisible background
				graphicsLayer.graphics.clear();
				graphicsLayer.graphics.beginFill(0, 0);
				graphicsLayer.graphics.drawRect(0, 0, graphicsLayer.width, graphicsLayer.height);
				setWarning(true);
				return;
			}
			// Redraw our dummy display node for the given node
			helperDisplayNode.redraw();
			// Copy bitmap data from dummy display node
			var scale:Number = radius / (Math.min(helperDisplayNode.height, helperDisplayNode.width) / 2 / helperDisplayNode.scaleX);
			var nodeW:Number = helperDisplayNode.width * 2 / helperDisplayNode.scaleX + FILTER_STROKE;
			var nodeH:Number = helperDisplayNode.height * 2 / helperDisplayNode.scaleY + FILTER_STROKE;
			nodeBitmap = new BitmapData(nodeW, nodeH, true, 0x00000000);
			var matrix:Matrix = new Matrix(scale, 0, 0, scale, radius, radius);
			nodeBitmap.draw(helperDisplayNode, matrix);
			// Draw onto bitmapHolder for display
			setWarning(false);
			graphicsLayer.graphics.clear();
			graphicsLayer.graphics.beginFill(0, 0);
			graphicsLayer.graphics.beginBitmapFill(nodeBitmap, null, false);
			graphicsLayer.graphics.drawRect(0, 0, scale * nodeW / 2, scale * nodeH / 2);
			graphicsLayer.width = radius * 2;
			graphicsLayer.height = radius * 2;
		}
		private function setWarning(val:Boolean):void
		{
			if(val)
			{
				if(graphicsLayer.numChildren) return;
				graphicsLayer.graphics.clear();
				var warningIcon:Bitmap = new IMAGE_WARNING;
				warningIcon.smoothing = true;
				var targetScale:Number = 1;
				if(warningIcon.width >= warningIcon.height) targetScale = _targetRadius*2 / warningIcon.width;
				else targetScale = _targetRadius*2 / warningIcon.height;
				warningIcon.scaleX = warningIcon.scaleY = targetScale;
				warningIcon.x = (graphicsLayer.width - warningIcon.width) / 2;
				warningIcon.y = (graphicsLayer.height - warningIcon.height) / 2;
				graphicsLayer.addChild(warningIcon);
				ToolTip.add(graphicsLayer, "Default destination must be set", {direction:"down", showDelay:0, width:220});
			}
			else
			{
				if(graphicsLayer.numChildren)
				{
					var warning:DisplayObject = graphicsLayer.removeChildAt(0);
					ToolTip.remove(graphicsLayer);
				}
			}
		}
		private function onGraphicMouseOver():void
		{
			if(!_interactive) return;
			helperDisplayNode.filters = FILTERSET_HIGHLIGHT;
			_redraw(_targetRadius);
		}
		private function onGraphicMouseOut():void
		{
			if(!_interactive) return;
			helperDisplayNode.filters = FILTERSET_NORMAL;
			_redraw(_targetRadius);
		}
		private function onMouseDown():void
		{
			if(!_interactive) return;
			if(bubble != null && bubble.visible)
			{
				_suspendNextBubble = true;
			}
			else
			{
				_suspendNextBubble = false;
			}
		}
		private function onClick():void
		{
			if(!_interactive) return;
			if(_suspendNextBubble)
			{
				_suspendNextBubble = false;
				return;
			}
			bubble = new DestinationBubble(this);
			bubble.show(this, bubbleDirection, this);
		}
	]]>
</mx:Script>
</mx:Canvas>