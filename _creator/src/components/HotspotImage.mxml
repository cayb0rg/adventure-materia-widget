<?xml version="1.0" encoding="utf-8"?>
<components:AdventureImage xmlns:mx="http://www.adobe.com/2006/mxml" xmlns:components="components.*"
                           creationComplete="onCreationComplete()">
	<mx:Script>
		<![CDATA[
			import components.bubbles.AdventureBubble;
			import components.bubbles.ColorPicker;
			import components.bubbles.HotspotBubble;
			import components.bubbles.HotspotSettingsBubble;
			
			import events.HotspotArrangementEvent;
			
			import hotspots.AdventureDisplayHotspot;
			import hotspots.AdventureHotspot;
			import hotspots.AdventureHotspotEllipse;
			import hotspots.AdventureHotspotPolygon;
			import hotspots.AdventureHotspotRect;
			
			import materia.questionStorage.Question;
			
			import tree.DisplayTree;
			import tree.Node;
			public static const EVENT_CHANGE_IMAGE:String = "ChangeImage";
			public var addNodeFunction:Function;
			private static const MIN_HOTSPOT_AREA:Number = 200;
			public var node:Node;
			protected var _toolbar:HotspotToolbar;
			protected var _mouseWasInside:Boolean = false;
			protected var _changeButton:FloatButton;
			protected var _toolsVisible:Boolean = false;
			protected var _redrawMode:Boolean = false;
			protected var _redrawTarget:AdventureDisplayHotspot;
			protected var _notificationBar:NotificationBar;
			protected var _hotspotColor:Number;
			protected var _hotspots:Array = new Array();
			protected var _currentHotspot:AdventureDisplayHotspot;
			protected var _creatingHotspot:int = -1;
			protected var _hotspotBubble:HotspotBubble;
			protected var _settingsBubble:HotspotSettingsBubble;
			protected var _settings:Object;
			protected var _lastClosedBubbleTarget:AdventureDisplayHotspot;
			protected var _lastMouseUpShape:Number;
			protected var _stage:*;
			public function showTools():void
			{
				if(_toolsVisible || _isCurrentlyEditing) return;
				_toolsVisible = true;
				// Create the toolbar
				_toolbar = new HotspotToolbar();
				_toolbar.show(displayedImage);
				_toolbar.addEventListener(HotspotToolbar.EVENT_HOTSPOT_CREATE, createNewHotspot, false, 0, false);
				_toolbar.addEventListener(HotspotToolbar.EVENT_HOTSPOT_SHOW, showHotspots, false, 0, false);
				_toolbar.addEventListener(HotspotToolbar.EVENT_HOTSPOT_HIDE, hideHotspots, false, 0, false);
				_toolbar.addEventListener(HotspotToolbar.EVENT_HOTSPOT_SETTINGS, showSettings, false, 0, false);
				_toolbar.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDownInside, false, 0, false);
				_toolbar.addEventListener(ColorPicker.EVENT_COLOR_CHANGED, onColorChanged, false, 0, false);
				// Show the change button
				_changeButton.show(displayedImage);
				_changeButton.addEventListener(MouseEvent.CLICK, onChangeButtonClick, false, 0, false);
				_changeButton.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDownInside, false, 0, false);
				// Add visibility listeners
				this.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDownInside, false, 0, true);
				_stage.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDownApplication, false, 0, true);
			}
			public function hideTools():void
			{
				if(!_toolsVisible) return;
				_toolsVisible = false;
				// Destroy the toolbar
				_toolbar.destroy();
				_toolbar.removeEventListener(HotspotToolbar.EVENT_HOTSPOT_CREATE, createNewHotspot);
				_toolbar.removeEventListener(HotspotToolbar.EVENT_HOTSPOT_SHOW, showHotspots);
				_toolbar.removeEventListener(HotspotToolbar.EVENT_HOTSPOT_HIDE, hideHotspots);
				_toolbar.removeEventListener(HotspotToolbar.EVENT_HOTSPOT_SETTINGS, showSettings);
				_toolbar.removeEventListener(MouseEvent.MOUSE_DOWN, onMouseDownInside);
				_toolbar.removeEventListener(ColorPicker.EVENT_COLOR_CHANGED, onColorChanged);
				_toolbar = null;
				// Hide the hotspot bubble
				if(_hotspotBubble != null && !_hotspotBubble.destroyed)
				{
					_hotspotBubble.destroySave();
				}
				// Hide the change button
				if(_changeButton != null) _changeButton.hide();
				_changeButton.removeEventListener(MouseEvent.CLICK, onChangeButtonClick);
				_changeButton.removeEventListener(MouseEvent.MOUSE_DOWN, onMouseDownInside);
				// Remove visibility listeners
				this.removeEventListener(MouseEvent.MOUSE_DOWN, onMouseDownInside);
				_stage.removeEventListener(MouseEvent.MOUSE_DOWN, onMouseDownApplication);
				// Remove hotspot listeners
				removeStartHotspotListeners()
			}
			public function loadHotspots():void
			{
				// Do nothing if there are no hotspots
				if(node.data.answers == null) return;
				// Load the stored color for the hotspots
				if(node.data.options.hotspotColor == null)_hotspotColor = _toolbar.colorPicker.colors[0];
				else _hotspotColor = Number(node.data.options.hotspotColor);
				_toolbar.colorPicker.setMainColor(_hotspotColor);
				// Load the hotspots
				for(var i:int = 0; i < node.data.answers.length; i++)
				{
					/* prevent loading 'default hotspot' as visible hotspot */
					if(i == 0 && node.data.answers[i].options.isDefault) continue;
					/* decode and build the hotspots */
					var hs:AdventureHotspot = AdventureUtils.decodeHotspot(node.data.answers[i].options.hotspot);
					var current:AdventureDisplayHotspot = createHotspot(hs.type, false);
					current.build(hs.points);
				}
			}
			public function removeHotspots():void
			{
				var target:AdventureDisplayHotspot;
				while(_hotspots.length)
				{
					target = _hotspots.pop();
					removeHotspotInteractionListeners(target);
					target.destroy();
					if(target.parent != null) target.parent.removeChild(target);
				}
			}
			public function updateHotspotScales(oldScale:Number, newScale:Number):void
			{
				for each(var hotspot:AdventureDisplayHotspot in _hotspots)
				{
//					hotspot.changeTargetScale(oldScale, newScale);
					hotspot.targetImage = displayedImage.content;
					/* Update Hotspot in QSet*/
					saveHotspotToQset(hotspot);
				}
			}
			public override function set allowScrollingAndSizing(allow:Boolean):void
			{
				super.allowScrollingAndSizing = allow;
				if(allow) hideTools();
			}
			protected override function onRepositionDone(event:Event):void
			{
				super.onRepositionDone(event);
				showTools();
			}
			protected function showSettings(e:Event):void
			{
				e.stopPropagation();
				/* If another hotspot was already pending, abort it */
				abortHotspotCreation();
				_toolbar.unPushButtons();
				/* If settings bubble is currently visible, destroy and ignore next call to show */
				if(_settingsBubble != null && _settingsBubble.visible)
				{
					_settingsBubble.destroy();
					return;
				}
				/* Create the settings bubble */
				_settingsBubble = new HotspotSettingsBubble(node, this);
				_settingsBubble.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDownInside, false, 0, true);
				_settingsBubble.show(HotspotToolbar(e.currentTarget).settingsButton, AdventureBubble.DIRECTION_LEFT);
			}
			protected function createHotspot(type:int, isNew:Boolean):AdventureDisplayHotspot
			{
				var clickedSameHotspot:Boolean = _creatingHotspot == type;
				/* If another hotspot was already pending, abort it and start over */
				abortHotspotCreation();
				/* If we clicked the select button twice, just stop here */
				if(clickedSameHotspot)
				{
					endRedrawHotspotMode(false);              // end redraw mode as failed
					return null;                              // exit here
				}
				switch(type)
				{
					case AdventureOptions.HOTSPOT_RECT:
						_currentHotspot = new AdventureHotspotRect(displayedImage.content);
						if(isNew)
						{
							_creatingHotspot = AdventureOptions.HOTSPOT_RECT;
							this.addEventListener(MouseEvent.MOUSE_DOWN, startRectHotspot, false, 0, true);
						}
						break;
					case AdventureOptions.HOTSPOT_ELLIPSE:
						_currentHotspot = new AdventureHotspotEllipse(displayedImage.content);
						if(isNew)
						{
							_creatingHotspot = AdventureOptions.HOTSPOT_ELLIPSE;
							this.addEventListener(MouseEvent.MOUSE_DOWN, startEllipseHotspot, false, 0, true);
						}
						break;
					case AdventureOptions.HOTSPOT_POLYGON:
						_currentHotspot = new AdventureHotspotPolygon(displayedImage.content);
						if(isNew)
						{
							_creatingHotspot = AdventureOptions.HOTSPOT_POLYGON;
							this.addEventListener(MouseEvent.MOUSE_DOWN, startPolygonHotspot, false, 0, true);
						}
						break;
				}
				_currentHotspot.color = _hotspotColor;
				_currentHotspot.id = _hotspots.length;
				_currentHotspot.settings = _settings;
				_settings.creationInProgress = true;
				_hotspots.push(_currentHotspot);
				drawingClip.addChild(_currentHotspot);
				if(!isNew) hotspotCreationComplete(false);
				return _currentHotspot;
			}
			/**
			 * Aborts the currently pending hotspot creation (if there is one).
			 * @return True if there was a pending hotspot that was aborted; false otherwise
			 */
			protected function abortHotspotCreation():Boolean
			{
				if(_creatingHotspot != -1)
				{
					removeStartHotspotListeners();            // remove start hotspot listeners
					drawingClip.removeChild(_hotspots.pop()); // remove hotspot from array & clip
					_settings.creationInProgress = false;
					return true;
				}
				return false;
			}
			/**
			 * Called when a hotspot is added and not pending completion
			 */
			protected function hotspotCreationComplete(hotspotIsNew:Boolean = true):void
			{
				_settings.creationInProgress = false;
				/* store reference to current hotspot */
				var hotspot:AdventureDisplayHotspot = _currentHotspot;
				/* ignore hotspot if it's too small */
				if(hotspotIsNew && hotspot.calculateArea() < MIN_HOTSPOT_AREA)
				{
					drawingClip.removeChild(_hotspots.pop());
					node.data.answers.pop();
					endRedrawHotspotMode(false);
					return;
				}
				/* Add click event listener */
				hotspot.addEventListener(MouseEvent.MOUSE_DOWN, onHotspotMouseDown, false, 0, true);
				callLater(function t():void { // used to avoid interference between finishing click and display click
					hotspot.addEventListener(MouseEvent.CLICK, onHotspotClicked, false, 0, true);
					if(hotspotIsNew) showBubbleForHotspot(hotspot, true);
				});
				/* Add drag listeners */
				hotspot.addEventListener(AdventureDisplayHotspot.EVENT_DRAG_BEGIN, onHotspotDragged, false, 0, true);
				hotspot.addEventListener(AdventureDisplayHotspot.EVENT_DRAG_END, onHotspotDragEnd, false, 0, true);
				/* Make sure the hotspot fits in the container */
//				checkBounds(hotspot);
				/* Add the new node to the tree and in the data */
				if(hotspotIsNew)
				{
					if(!_redrawMode) // if it's a new hotspot
					{
						var newNode:Node;
						// If we have a child with no answer attached, this newly added hotspot will be matched to the child
						if(node.data.answers.length == node.children.length) newNode = node.children[node.children.length - 1];
						// otherwise, create a new child
						else newNode = addNodeFunction(node);
						node.data.answers[node.data.answers.length - 1].options.link = newNode.id;
					}
					else // if it's an existing hotspot being redrawn
					{
						// remove new hotspot from array for now
						_hotspots.pop();
						node.data.answers.pop();
						// replace old hotspot with this one
						replaceHotspot(hotspot, _redrawTarget);
						endRedrawHotspotMode(true);
					}
				}
			}
			/**
			 * Replaces an old hotspot with a new one while keeping the old
			 * hotspot's data, id, and address in _hotspots array. This is used
			 * for redrawing hotspots.
			 */
			protected function replaceHotspot(newHotspot:AdventureDisplayHotspot, oldHotspot:AdventureDisplayHotspot):void
			{
				newHotspot.id = oldHotspot.id;
				newHotspot.data = oldHotspot.data;
				_hotspots[newHotspot.id + (hasDefault ? 1 : 0)] = newHotspot;
				saveHotspotToQset(newHotspot);
			}
			protected function removeStartHotspotListeners():void
			{
				if(_creatingHotspot == AdventureOptions.HOTSPOT_POLYGON)
				{
					removePolygonHotspotListeners();
				}
				_creatingHotspot = -1;
				this.removeEventListener(MouseEvent.MOUSE_DOWN, startRectHotspot);
				this.removeEventListener(MouseEvent.MOUSE_DOWN, startEllipseHotspot);
				this.removeEventListener(MouseEvent.MOUSE_DOWN, startPolygonHotspot);
			}
			protected function removeHotspotInteractionListeners(hotspot:AdventureDisplayHotspot):void
			{
				hotspot.removeEventListener(MouseEvent.CLICK, onHotspotClicked);
				hotspot.removeEventListener(MouseEvent.MOUSE_DOWN, onHotspotMouseDown);
				hotspot.removeEventListener(AdventureDisplayHotspot.EVENT_DRAG_BEGIN, onHotspotDragged);
				hotspot.removeEventListener(AdventureDisplayHotspot.EVENT_DRAG_END, onHotspotDragEnd);
			}
			protected function createNewHotspot(e:DataEvent):void
			{
				e.stopPropagation();
				createHotspot(int(e.data), true);
			}
			protected function showHotspots(e:Event):void
			{
				e.stopPropagation();
				for each(var hotspot:AdventureDisplayHotspot in _hotspots)
				{
					hotspot.visible = true;
				}
			}
			protected function hideHotspots(e:Event):void
			{
				e.stopPropagation();
				for each(var hotspot:AdventureDisplayHotspot in _hotspots)
				{
					hotspot.visible = false;
				}
			}
			//----------------------------------
			//  Begin Rect Hotspot
			//----------------------------------
			protected function startRectHotspot(e:MouseEvent):void
			{
				removeStartHotspotListeners();
				var hotspot:AdventureHotspotRect = AdventureHotspotRect(_currentHotspot);
				var focusPoint:Point = drawingClip.globalToLocal(new Point(e.stageX, e.stageY));
				hotspot.x = focusPoint.x
				hotspot.y = focusPoint.y;
				stage.addEventListener(MouseEvent.MOUSE_MOVE, hotspot.onMouseMoveCreate, false, 0, true);
				stage.addEventListener(MouseEvent.MOUSE_UP, stopRectHotspot, false, 0, true);
			}
			protected function stopRectHotspot(e:Event):void
			{
				/* get a shortcut reference to current hotspot */
				var hotspot:AdventureHotspotRect = AdventureHotspotRect(_currentHotspot);
				/* remove listeners */
				_stage.removeEventListener(MouseEvent.MOUSE_UP, stopRectHotspot);
				_stage.removeEventListener(MouseEvent.MOUSE_MOVE, hotspot.onMouseMoveCreate);
				/* prevent accidental creation from duplicate events being fired */
				var currentTime:Number = (new Date()).time;
				if((currentTime-_lastMouseUpShape) < 500) return;
				_lastMouseUpShape = currentTime;
				/* create the hotspot */
				hotspot.finalize();
				if(node.data.answers == null) node.data.answers = new Array();
				node.data.addAnswer("Hotspot " + String(node.data.answers.length + 1), "100", {hotspot:AdventureUtils.encodeHotspot(hotspot.getHotspot())});
				hotspotCreationComplete();
				_toolbar.unPushButtons();
			}
			//----------------------------------
			//  Begin Ellipse Hotspot
			//----------------------------------
			protected function startEllipseHotspot(e:MouseEvent):void
			{
				removeStartHotspotListeners();
				var hotspot:AdventureHotspotEllipse = AdventureHotspotEllipse(_currentHotspot);
				var focusPoint:Point = drawingClip.globalToLocal(new Point(e.stageX, e.stageY));
				hotspot.x = focusPoint.x
				hotspot.y = focusPoint.y;
				stage.addEventListener(MouseEvent.MOUSE_MOVE, hotspot.onMouseMoveCreate, false, 0, true);
				stage.addEventListener(MouseEvent.MOUSE_UP, stopEllipseHotspot, false, 0, true);
			}
			protected function stopEllipseHotspot(e:Event):void
			{
				/* get a shortcut reference to current hotspot */
				var hotspot:AdventureHotspotEllipse = AdventureHotspotEllipse(_currentHotspot);
				/* remove listeners */
				stage.removeEventListener(MouseEvent.MOUSE_UP, stopRectHotspot);
				stage.removeEventListener(MouseEvent.MOUSE_MOVE, hotspot.onMouseMoveCreate);
				/* prevent accidental creation from duplicate events being fired */
				var currentTime:Number = (new Date()).time;
				if((currentTime-_lastMouseUpShape) < 500) return;
				_lastMouseUpShape = currentTime;
				/* create the hotspot */
				EventDispatcher(e.currentTarget).removeEventListener(e.type, arguments.callee);
				hotspot.finalize();
				if(node.data.answers == null) node.data.answers = new Array();
				node.data.addAnswer("Hotspot " + String(node.data.answers.length + 1), "100", {hotspot:AdventureUtils.encodeHotspot(hotspot.getHotspot())});
				hotspotCreationComplete();
				_toolbar.unPushButtons();
			}
			//----------------------------------
			//  Begin Polygon Hotspot
			//----------------------------------
			protected function startPolygonHotspot(e:MouseEvent):void
			{
				removeStartHotspotListeners();
				_creatingHotspot = AdventureOptions.HOTSPOT_POLYGON;
				var hotspot:AdventureHotspotPolygon = AdventureHotspotPolygon(_currentHotspot);
				var focusPoint:Point = drawingClip.globalToLocal(new Point(e.stageX, e.stageY));
				hotspot.x = focusPoint.x
				hotspot.y = focusPoint.y;
				hotspot.addPoint(e);
				this.addEventListener(MouseEvent.MOUSE_MOVE, hotspot.onMouseMoveCreate, false, 0, true);
				this.addEventListener(MouseEvent.MOUSE_DOWN, continuePolygonHotspot, false, 0, true);
				hotspot.addEventListener(AdventureHotspotPolygon.CONNECTED, endPolygonHotspot, false, 0, true);
				this.addEventListener(MouseEvent.DOUBLE_CLICK, endPolygonHotspot, false, -99, true);
			}
			protected function continuePolygonHotspot(e:MouseEvent):void
			{
				var hotspot:AdventureHotspotPolygon = AdventureHotspotPolygon(_currentHotspot);
				hotspot.addPoint(e);
			}
			protected function endPolygonHotspot(e:Event):void
			{
				e.stopImmediatePropagation();
				removePolygonHotspotListeners();
				_currentHotspot.finalize();
				if(node.data.answers == null) node.data.answers = new Array();
				node.data.addAnswer("Hotspot " + String(node.data.answers.length + 1), "100", {hotspot:AdventureUtils.encodeHotspot(_currentHotspot.getHotspot())});
				_creatingHotspot = -1;
				hotspotCreationComplete();
				_toolbar.unPushButtons();
			}
			/**
			 * Moves a hotspot up or down in arrangement order
			 * @param up Moves the hotspot up if true, down otherwise
			 */
			protected function changeHotspotArrangement(targetHotspot:AdventureDisplayHotspot, up:Boolean):void
			{
				var arrayIndex:int = -1;
				var drawIndex:int = -1;
				var answer:Object;
				/* search for the given hotspot in our hotspots array */
				for(var i:int = 0; i < _hotspots.length; i++)
				{
					if(_hotspots[i] == targetHotspot)
					{
						arrayIndex = i;
						break;
					}
				}
				if(arrayIndex == -1) return;
				/* search for the given hotspot in our drawing clip */
				for(i = 0; i < drawingClip.numChildren; i++)
				{
					if(drawingClip.getChildAt(i) == targetHotspot)
					{
						drawIndex = i;
						break;
					}
				}
				if(drawIndex == -1) return;
				/* if we want to move up and we CAN move up */
				if(up && arrayIndex + 1 < _hotspots.length && drawIndex + 1 < drawingClip.numChildren)
				{
					/* move up one in hotspots array */
					_hotspots.splice(arrayIndex, 1);
					_hotspots.splice(arrayIndex + 1, 0, targetHotspot);
					/* move up one in answer array array */
					answer = node.data.answers.splice(arrayIndex + (hasDefault ? 1 : 0), 1);
					node.data.answers.splice(arrayIndex + (hasDefault ? 2 : 1), 0, answer[0]);
					/* move up one in drawing clip */
					drawingClip.removeChildAt(drawIndex);
					drawingClip.addChildAt(targetHotspot, drawIndex + 1);
				}
				/* otherwise, if we want to move down and we CAN move down */
				else if(!up && arrayIndex > 0 && drawIndex > 0)
				{
					/* move down one in hotspots array */
					_hotspots.splice(arrayIndex, 1);
					_hotspots.splice(arrayIndex - 1, 0, targetHotspot);
					/* move down one in drawing clip */
					drawingClip.removeChildAt(drawIndex);
					drawingClip.addChildAt(targetHotspot, drawIndex - 1);
				}
			}
			//----------------------------------
			//  END Hotspots
			//----------------------------------
			protected function removePolygonHotspotListeners():void
			{
				var hotspot:AdventureHotspotPolygon = AdventureHotspotPolygon(_currentHotspot);
				hotspot.removeEventListener(AdventureHotspotPolygon.CONNECTED, endPolygonHotspot);
				this.removeEventListener(MouseEvent.MOUSE_MOVE, hotspot.onMouseMoveCreate);
				this.removeEventListener(MouseEvent.DOUBLE_CLICK, endPolygonHotspot);
				this.removeEventListener(MouseEvent.MOUSE_DOWN, continuePolygonHotspot);
			}
			protected function onCreationComplete():void
			{
				_changeButton = new FloatButton();
				_changeButton.label = "Change Image";
				this.doubleClickEnabled = true;
				// initialize hotspot settings
				_settings = new Object();
				_settings.creationInProgress = false;
				// Create Notification Bar
				_notificationBar = new NotificationBar();
				//
				drawingClip.graphics.beginFill(0, 0);
				drawingClip.graphics.drawRect(0, 0, this.width, this.height);
				// keep reference of stage because we might not always have it
				_stage = stage;
			}
			protected function onArrangeUp(e:HotspotArrangementEvent):void
			{
				changeHotspotArrangement(e.hotspot, true);
			}
			protected function onLayerChangeDown(e:HotspotArrangementEvent):void
			{
				changeHotspotArrangement(e.hotspot, false);
			}
			protected function onMouseDownInside(e:Event):void
			{
				_mouseWasInside = true;
			}
			protected function onMouseDownApplication(e:Event):void
			{
//				if(!_mouseWasInside) hideTools();
				if(_mouseWasInside) _mouseWasInside = false;
			}
			protected function onHotspotDragged(e:Event):void
			{
//				hideHotspotBubble(true);
			}
			protected function onHotspotMouseDown(e:Event):void
			{
				if(_hotspotBubble != null && _hotspotBubble.destroyed == false)
				{
					_lastClosedBubbleTarget = _hotspotBubble.hotspot;
				}
				else
				{
					_lastClosedBubbleTarget = null;
				}
			}
			protected function onHotspotClicked(e:Event):void
			{
				var targetHotspot:AdventureDisplayHotspot = AdventureDisplayHotspot(e.target);
				if(targetHotspot != _lastClosedBubbleTarget)
				{
					showBubbleForHotspot(targetHotspot);
				}
			}
			protected function onHotspotDelete(e:Event):void
			{
				// Delete the hotspot
				deleteHotspot(HotspotBubble(e.target).hotspot);
				// Destroy the hotspot bubble
				hideHotspotBubble(false);
			}
			/**
			 * Delete the given hotspot from the tree and the qset
			 * @param hotspot The hotspot to delete
			 */
			protected function deleteHotspot(hotspot:AdventureDisplayHotspot):void
			{
				// Delete from the tree & QSet
				var targetNode:Node = node.children[hotspot.id + (hasDefault ? 1 : 0)];
				if(!displayTree.attemptDeleteNode(targetNode, false)) return;
				// Delete from list of hotspots & Hotspot display
				for(var i:int = hotspot.id + 1; i < _hotspots.length; i++)
				{
					_hotspots[i].id--;
					_hotspots[i-1] = _hotspots[i];
				}
				_hotspots.pop();
				if(hotspot.parent != null) hotspot.parent.removeChild(hotspot);
			}
			protected function onHotspotRedraw(e:Event):void
			{
				beginRedrawHotspotMode(HotspotBubble(e.target).hotspot);
				hideHotspotBubble(true);
			}
			protected function beginRedrawHotspotMode(hotspot:AdventureDisplayHotspot):void
			{
				hotspot.visible = false;
				_redrawMode = true;
				_redrawTarget = hotspot;
				// Highlight the hotspot creation buttons
				if(_toolbar == null) showTools();
				_toolbar.highlightCreateButtons();
				// Position and Show the Notification Bar
				stage.addChild(_notificationBar);
				var startPoint:Point = _notificationBar.parent.globalToLocal((this.localToGlobal(new Point(0,0))));
				_notificationBar.x = startPoint.x + this.width / 2 - _notificationBar.width / 2;
				_notificationBar.y = Math.min(_toolbar.y - 10, startPoint.y) - _notificationBar.height;
				_notificationBar.show("Click on a shape to begin drawing a new hotspot", "Cancel", endRedrawHotspotMode);
			}
			/**
			 * Turns off redraw mode if we're in it. Removes old hotspot if the
			 * replacement/redrawing was successful, reinstates it otherwise.
			 * @param replaced Whether or not the redraw/replace was successful
			 */
			public function endRedrawHotspotMode(replaced:Boolean = false):void
			{
				if(!_redrawMode) return;
				// turn off redraw mode
				_redrawMode = false;
				// hide notification bar
				_notificationBar.hide();
				if(_notificationBar.parent != null) stage.removeChild(_notificationBar);
				// UnHighlight the hotspot creation buttons
				if(_toolbar != null) _toolbar.unHighlightCreateButtons();
				// if replacement was successful, remove redraw target
				if(replaced)
				{
					if(_redrawTarget.parent != null) _redrawTarget.parent.removeChild(_redrawTarget);
					_redrawTarget = null;
				}
				else
				{
					_redrawTarget.visible = true;
					_redrawTarget = null;
				}
			}
			protected function onColorChanged(e:DataEvent):void
			{
				var newColor:Number = Number(e.data);
				_hotspotColor = newColor;
				for each (var hotspot:AdventureDisplayHotspot in _hotspots)
				{
					hotspot.color = _hotspotColor;
					hotspot.redraw();
				}
				// Save to Qset
				node.data.options.hotspotColor = _hotspotColor;
			}
			/**
			 * Checks if it is appropriate to create a hotspot bubble and then
			 * creates one with a delay keep from confusing click events
			 *
			 * @hotspot The hostspot the bubble should focus on
			 * @autoFocus Whether or not the Label field should have focus & be selected
			 */
			protected function showBubbleForHotspot(hotspot:AdventureDisplayHotspot, autoFocus:Boolean = false):void
			{
				/* If the bubble already exists, do nothing */
				if(_hotspotBubble != null && _hotspotBubble.destroyed == false && _hotspotBubble.hotspot == hotspot)
				{
					return;
				}
				/* Otherwise, create the new bubble */
				callLater(showHotspotBubble, [hotspot, autoFocus]);
			}
			/**
			 * Creates a hotspot bubble for the given hotspot with no checks or delays.
			 *
			 * @hotspot The hostspot the bubble should focus on
			 * @autoFocus Whether or not the Label field should have focus & be selected
			 */
			protected function showHotspotBubble(hotspot:AdventureDisplayHotspot, autoFocus:Boolean = false):void
			{
				/* Don't show hotspot bubble if we're redrawing another hotspot */
				if(_redrawMode) return;
				/* determine direction of popup */
				var direction:int = AdventureBubble.DIRECTION_UP;
				var targetPoint:Point = hotspot.localToGlobal(new Point(hotspot.width / 2, 0));
				if(targetPoint.y - HotspotBubble.HEIGHT - HotspotBubble.SPACING < 0)
				{
					if(targetPoint.x < stage.width / 2)
					{
						direction = AdventureBubble.DIRECTION_RIGHT;
					}
					else
					{
						direction = AdventureBubble.DIRECTION_LEFT;
					}
				}
				/* Create the new bubble */
				_hotspotBubble = new HotspotBubble(node, hotspot, this);
				_hotspotBubble.addEventListener(HotspotArrangementEvent.ARRANGE_UP, onArrangeUp, false, 0, true);
				_hotspotBubble.addEventListener(HotspotArrangementEvent.ARRANGE_DOWN, onLayerChangeDown, false, 0, true);
				_hotspotBubble.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDownInside, false, 0, true);
				_hotspotBubble.addEventListener(HotspotBubble.EVENT_DELETE, onHotspotDelete, false, 0, true);
				_hotspotBubble.addEventListener(HotspotBubble.EVENT_REDRAW, onHotspotRedraw, false, 0, true);
				_hotspotBubble.show(hotspot, direction, this);
				if(autoFocus) _hotspotBubble.setLabelFocus();
			}
			/**
			 * Destroys our hotspot bubble and removes all associated listeners
			 * @param save Whether or not to save the data in the hotspot bubble before destroying it
			 */
			protected function hideHotspotBubble(save:Boolean = false):void
			{
				/* If the hotspot's bubble is visible, destroy it */
				if(_hotspotBubble != null && _hotspotBubble.visible)
				{
					if(save) _hotspotBubble.destroySave();
					else _hotspotBubble.destroy();
					_hotspotBubble.removeEventListener(HotspotArrangementEvent.ARRANGE_UP, onArrangeUp);
					_hotspotBubble.removeEventListener(HotspotArrangementEvent.ARRANGE_DOWN, onLayerChangeDown);
					_hotspotBubble.removeEventListener(MouseEvent.MOUSE_DOWN, onMouseDownInside);
					_hotspotBubble.removeEventListener(HotspotBubble.EVENT_DELETE, onHotspotDelete);
					_hotspotBubble.removeEventListener(HotspotBubble.EVENT_REDRAW, onHotspotRedraw);
					_hotspotBubble = null;
				}
			}
			protected function onHotspotDragEnd(e:Event):void
			{
				/* Get Refernce to Hotspot */
				var hotspot:AdventureDisplayHotspot = AdventureDisplayHotspot(e.target);
				/* Maintain Boundaries So We Don't Lose Hotspot */
				checkBounds(hotspot);
				/* Prevent Click Event from Being Registered */
				hotspot.removeEventListener(MouseEvent.CLICK, onHotspotClicked);
				callLater(function t():void {
					hotspot.addEventListener(MouseEvent.CLICK, onHotspotClicked, false, 0, true);
				});
				/* Update Position Reference */
				saveHotspotToQset(hotspot);
			}
			protected function checkBounds(hotspot:AdventureDisplayHotspot):void
			{
				if(hotspot.width <= this.width) // don't force boundaries if too big to fit in boundaries
				{
					if(hotspot.x < 0) hotspot.x = 0;
					else if(hotspot.x > this.width - hotspot.width) hotspot.x = this.width - hotspot.width;
				}
				if(hotspot.height <= this.height)
				{
					if(hotspot.y < 0) hotspot.y = 0;
					else if(hotspot.y > this.height - hotspot.height) hotspot.y = this.height - hotspot.height;
				}
			}
			protected function saveHotspotToQset(hotspot:AdventureDisplayHotspot):void
			{
				node.data.answers[hotspot.id + (hasDefault ? 1 : 0)].options.hotspot = AdventureUtils.encodeHotspot(hotspot.getHotspot());
			}
			protected function onChangeButtonClick(e:Event):void
			{
				dispatchEvent(new Event(EVENT_CHANGE_IMAGE));
			}
			private function get displayTree():DisplayTree
			{
				return node.displayNode.displayTree;
			}
			private function get hasDefault():Boolean
			{
				return node.data.answers.length && node.data.answers[0].options.isDefault;
			}
		]]>
	</mx:Script>
</components:AdventureImage>