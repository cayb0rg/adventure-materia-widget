<?xml version="1.0" encoding="utf-8"?>
<screens:AdventurePopupBase
	xmlns:mx="http://www.adobe.com/2006/mxml"
	xmlns:components="components.*"
	title="Edit Multiple Choice Question"
	layout="absolute" width="950" height="620"
	xmlns:screens="screens.*"
	>
	<mx:Script>
		<![CDATA[
			import components.FloatButton;
			import components.ScoreBox;

			import materia.CreatorBase;
			import materia.CreatorConfig;
			import materia.components.ScrollableSizableImage;

			import mx.events.FlexEvent;

			import nm.ui.ToolTip;
			use namespace mx_internal;
			import components.MultipleChoiceRow;
			import tree.DisplayNode;
			import tree.DisplayTree;
			import tree.Node;
			import mx.core.UITextField;
			import materia.questionStorage.Question;
			[Bindable]
			public var rowOffset:int = 0;
			private static const DEFAULT_TEXT:String = "Enter question here.";
			[Embed(source="../assets/image_icon.png")]
			private static var AddImageIcon:Class;
			protected var numQuestions:int = 0;
			[Bindable]
			protected var nodeID:String;
			protected var addAnswerButton:AdventureButton;
			private var _layout:int = AdventureOptions.LAYOUT_TEXT_ONLY;
			private var _assetId:int = -1;
			private var _deleteTarget:MultipleChoiceRow;
			private var _scrollDownPending:Boolean = false;
			private var _scrollUpdatePending:Boolean = false;

			protected override function onCreationComplete():void
			{
				super.onCreationComplete();
				this.addEventListener(DisplayNode.EVENT_FIND_LINK, onEditLink, false, 1, true);
				answerVBox.removeChild(answerInstructions);
				_sidePanel.visible = false;
				removeChild(deleteButton);
				deleteButton.rotation = -90;

				// Add relevant helper bubbles
				if (!_creator.helperManager.destinationsBubble.alreadyActivated)
				{
					_creator.helperManager.addHelper(_creator.helperManager.destinationsBubble);
				}

				if (!_creator.helperManager.mcBubble.alreadyActivated)
				{
					_creator.helperManager.addHelper(_creator.helperManager.mcBubble);
				}
			}
			protected override function fixImportedData(node:Node):void
			{
				super.fixImportedData(node);
				for(var i:int = rowOffset; i < node.data.answers.length; i++)
				{
					var newNode:Node = addNode(node);
					_newNodes.push(newNode);
					node.data.answers[i].options.link = newNode.id;
					node.data.answers[i].options.validScore = true;
				}
				_node.imported = false;
			}
			protected override function beginEdit(node:Node):void
			{
				super.beginEdit(node);
				nodeID = DisplayNode.idToLabel(node.id);
				this.title = "Edit Multiple Choice - " + nodeID;
				this.nodeBox.setTargetNode(node, DestinationBox.RADIUS_DEFAULT, false);
				if(node.data.options.randomize != null) randomizeBox.selected = node.data.options.randomize;
				else randomizeBox.selected = true;
				/* Load Question Text */
				qField.text = node.data.question;
				// qField.opaqueBackground = 0xfef6b1;
				// qField.opaqueBackground = 0xfffdef;
				qField.opaqueBackground = 0xe2edf4;
				if(!qField.text.length) qField.text = DEFAULT_TEXT;
				updateQuestionColor();
				/* Load Answers */
				loadAnswers();
				// Set this node to the appropriate type
				_node.data.addOption("type", AdventureOptions.TYPE_MULTIPLE_CHOICE);
				if(_node.data.options.layout != null) setLayout(_node.data.options.layout);
				else setLayout(AdventureOptions.LAYOUT_TEXT_ONLY);
				// Add an answer if this is a new node
				if(node.isNew)
				{
					if(node.children.length == 0) onAddAnswer(null);
					else if(node.data.answers.length == 0) addAnswerForNode(node.children[0]);
					trace("Added a new node");
				}
				/* Create the "Add Answer" Button */
				addAnswerButton = new AdventureButton();
				addAnswerButton.usePlus = true;
				addAnswerButton.anchored = true;
				addAnswerButton.label = "Add Answer Choice";
				addAnswerButton.addEventListener(MouseEvent.CLICK, onAddAnswer,false, 0, true);
				addAnswerButton.visible = false;
				PopUpManager.addPopUp(addAnswerButton, this);
				updateAddAnswerButton(node.isNew);
				trace("Add answer button being updated from: beginEdit (PopupMc)");
				addAnswerButton.visible = true;
				// Create Delete Button
				PopUpManager.addPopUp(deleteButton, this);
				/* update header labels depending on score type */
				// TODO: Update for participationMode

				// These values are now fixed because of the change to Destination Mode only.
				scoreHeaderLabel.visible = false;
				destinationHeaderLabel.setStyle("right", 10);

				// scoreHeaderLabel.visible = true;
				// destinationHeaderLabel.setStyle("right", 110);

			}
			protected override function onWindowClosed():void
			{
				deleteButton.visible = false;
				// Remove the add answer button from parent
				if(addAnswerButton.parent != null) PopUpManager.removePopUp(addAnswerButton);
				addAnswerButton.removeEventListener(MouseEvent.CLICK, onAddAnswer);
				addAnswerButton = null;
				/* check for lack of image in image layout */
				if(_assetId == -1)
				{
					_layout = AdventureOptions.LAYOUT_TEXT_ONLY
				}
				/* Save the Question */
				if(qField.text != DEFAULT_TEXT) _node.data.question = qField.text;
				_node.data.options.id = _node.id;
				_node.data.options.layout = _layout;
				_node.data.options.randomize = randomizeBox.selected;
				/* Save the Answers */
				saveAnswers();
				/* Remove All the Rows */
				while(mcList.numChildren)
				{
					var row:MultipleChoiceRow = MultipleChoiceRow(mcList.removeChildAt(0));
					row.removeEventListener(FocusEvent.FOCUS_IN, onRowFocusIn);
					row.removeEventListener(FocusEvent.FOCUS_OUT, onRowFocusOut);
					row.destroy();
				}
				mcList.removeAllChildren();
				// Remove the delete button
				PopUpManager.removePopUp(deleteButton);
				/* Update tooltip for the node and its position if necessary */
				_tree.redraw();
				// Unload assets
				_assetId = -1;
				nodeImg.source = "";
				// call super
				super.onWindowClosed();

				// Remove all the helper bubbles
				if (_creator.helperManager.destinationsBubble.visible)
				{
					_creator.helperManager.destinationsBubble.destroy();
				}
				if (_creator.helperManager.mcBubble.visible)
				{
					_creator.helperManager.mcBubble.destroy();
				}
				if (!_creator.helperManager.endSuggestionBubble.alreadyActivated)
				{
					_creator.helperManager.addHelper(_creator.helperManager.endSuggestionBubble);
				}
			}
			/**
			 * Load answers from the qset into the multiple choice list
			 */
			protected function loadAnswers():void
			{
				numQuestions = 0; // reset counter for letters to zero
				var row:MultipleChoiceRow;
				for(var i:int = rowOffset; i < _node.data.answers.length; i++)
				{
					var ans:Object = _node.data.answers[i];
					row = new MultipleChoiceRow();
					row.popupInstance = this;
					row.node = _node;
//					row.letter = getNextLetter();
					trace("loading answer text: " + ans.text);

					row.text = ans.text;
					row.destination = _node.children[i];
					row.feedback = ans.options.feedback;
					row.rowIndex = mcList.numChildren;
					row.addEventListener(FocusEvent.FOCUS_IN, onRowFocusIn, false, 1, true);
					row.addEventListener(FocusEvent.FOCUS_OUT, onRowFocusOut, false, 0, true);
					mcList.addChild(row);
				}
			}
			/**
			 * Saves answers from the multiple choice list to the qset
			 */
			protected function saveAnswers():void
			{
				// var scoreMode:int = _node.displayNode.displayTree.scoreStyle;
				var row:MultipleChoiceRow;
				for(var i:int = 0; i < mcList.numChildren; i++)
				{
					row = MultipleChoiceRow(mcList.getChildAt(i))
					trace("saving row text: " + row.text);
					_node.data.answers[i + rowOffset].text = row.text == MultipleChoiceRow.DEFAULT_ANS_TEXT ? "" : row.text;
					// TODO: add scoring option
					// _node.data.answers[i].value = MultipleChoiceRow(mcList.getChildAt(i)).value;
					_node.data.answers[i + rowOffset].options.link = row.destination.id;
					_node.data.answers[i + rowOffset].options.feedback = row.feedback;
					/* save scoring details */
					/*
					if(scoreMode == AdventureOptions.SCORESTYLE_QUIZ)
					{
						_node.data.answers[i + rowOffset].value = row.scoreBox.value;
						if(isNaN(row.scoreBox.value))
						{
							_node.data.answers[i + rowOffset].value = null;
							_node.data.answers[i + rowOffset].options.unscored = false;
						}
					}
					else if(scoreMode == AdventureOptions.SCORESTYLE_QUEST)
					{
					}
					*/
				}
			}
			/**
			 * Moves the "Add Answer" button to its required position.
			 * It should be aligned to the left and below the lowest row entry,
			 * but no lower than the bottom of the answers container.
			 */
			protected function updateAddAnswerButton(isNew:Boolean = false):void
			{
				if(addAnswerButton == null) return;
				var targetPoint:Point = addAnswerButton.parent.globalToLocal(scrollCanvas.localToGlobal(new Point(0, 0)));

				addAnswerButton.x = targetPoint.x + addAnswerButton.padding;
				addAnswerButton.y = targetPoint.y + Math.min(( mcList.numChildren * (mcList.getStyle("verticalGap") + MultipleChoiceRow.rowHeight)), scrollCanvas.height) + addAnswerButton.padding + 1;
			}
			public override function destroy():void
			{
				this.visible = false;
				PopUpManager.removePopUp(this);
				ToolTip.remove(deleteButton);
				if(deleteButton != null && deleteButton.parent != null) PopUpManager.removePopUp(deleteButton);
			}
			/**
			 * Called after a child destination's reference is updated
			 */
			public override function onDoneEditingLink():void
			{
				/* bring window back to focus */
				this.visible = true;
				if(addAnswerButton) addAnswerButton.visible = true;
				if(deleteButton) deleteButton.visible = true;
				/* update reflected destination for all answers */
				for(var i:int = 0; i < mcList.numChildren; i++)
				{
					MultipleChoiceRow(mcList.getChildAt(i)).destination = _node.children[i + rowOffset];
				}
			}
			/**
			 * Checks if the given node id is considered "new" for this window.
			 */
			public function isNew(id:int):Boolean
			{
				for(var i:int = 0; i < _newNodes.length; i++)
				{
					if(_newNodes[i].id == id) return true;
				}
				return false;
			}
			/**
			 * Called when a child destination is to be edited.
			 * Shows the display tree and allows choosing a new link
			 */
			protected override function onEditLink(e:Event):void
			{
				/* hide window and popup components to show node tree */
				if(addAnswerButton) addAnswerButton.visible = false;
				if(deleteButton) deleteButton.visible = false;
				this.visible = false;
			}
			private function setLayout(layout:int):void
			{
				_layout = layout;
				switch(layout)
				{
					case AdventureOptions.LAYOUT_TEXT_ONLY:
						//if(swapContainer.parent == questionHBox) questionHBox.removeChild(swapContainer);
						if(imageContainer.parent == questionHBox) questionHBox.removeChild(imageContainer);
						contentHBox.addChildAt(addImageButton, 1);
						layoutButton2.setStyle('borderStyle', 'none');
						layoutButton3.setStyle('borderStyle', 'none');
						layout2ButtonOverlay.visible = false;
						layout3ButtonOverlay.visible = false;
						callLater(updateLayoutsWindowVisibility, [false]);
						break;
					case AdventureOptions.LAYOUT_HORIZ_TEXT:
						if(addImageButton.parent == contentHBox) contentHBox.removeChild(addImageButton);
						questionHBox.addChildAt(qField, 1);
						//questionHBox.addChildAt(swapContainer, 2);
						questionHBox.addChildAt(imageContainer, 3);
						updateImage(_node.data.options.assetId);
						layoutButton2.setStyle('borderStyle', 'solid');
						layoutButton3.setStyle('borderStyle', 'none');
						layout2ButtonOverlay.visible = true;
						layout3ButtonOverlay.visible = false;
						callLater(updateLayoutsWindowVisibility, [true]);
						break;
					case AdventureOptions.LAYOUT_HORIZ_IMAGE:
						if(addImageButton.parent == contentHBox) contentHBox.removeChild(addImageButton);
						questionHBox.addChildAt(imageContainer, 1);
						// questionHBox.addChildAt(swapContainer, 2);
						questionHBox.addChildAt(qField, 3);
						updateImage(_node.data.options.assetId);
						layoutButton2.setStyle('borderStyle', 'none');
						layoutButton3.setStyle('borderStyle', 'solid');
						layout2ButtonOverlay.visible = false;
						layout3ButtonOverlay.visible = true;
						callLater(updateLayoutsWindowVisibility, [true]);
						break;
				}
			}
			private function updateLayoutsWindowVisibility(visible:Boolean):void
			{
				layoutsWindow.visible = visible;
				layoutsWindow.includeInLayout = visible;
				/*
				deleteImageButton.visible = visible;
				var point:Point = deleteImageButton.parent.globalToLocal(imageContainer.localToGlobal(new Point(nodeImg.x, nodeImg.y)));
				deleteImageButton.x = point.x + nodeImg.width - deleteImageButton.width - AdventureButton.ANCHOR_PADDING;
				deleteImageButton.y = point.y + nodeImg.height - getStyle("headerHeight") + AdventureButton.ANCHOR_PADDING;
				addChild(deleteImageButton); // bring to front
				*/
				updateChangeImageButton();
			}
			private function updateChangeImageButton():void
			{
				changeImageButton.visible = _assetId >= 0 && _layout != AdventureOptions.LAYOUT_TEXT_ONLY;
				imageContainer.mouseEnabled = !changeImageButton.visible;
				imageContainer.mouseChildren = imageContainer.mouseEnabled;
				if(changeImageButton.visible)
				{
					// changeImageButton.y = deleteImageButton.y;
					// changeImageButton.x = deleteImageButton.x - changeImageButton.width - AdventureButton.ANCHOR_PADDING * 2 - 10;
					addChild(changeImageButton); // bring to front
				}
			}
			private function updateImage(assetId:* = null):void
			{
				if(assetId != null)
				{
					if(assetId == _assetId) return;
					_assetId = assetId;
					nodeImg.addEventListener(ScrollableSizableImage.EVENT_IMAGE_LOAD_COMPLETE, onLoadImageComplete, false, 0, true);
					nodeImg.source = CreatorConfig.getKogneatoAssetLink(assetId);
					callLater(updateChangeImageButton);
				}
				else
				{
					nodeImg.source = new AddImageIcon();
					callLater(function t():void { nodeImg.centerImage(); });
					callLater(updateChangeImageButton);
				}
			}
			private function onLoadImageComplete(e:Event = null):void
			{
				nodeImg.removeEventListener(ScrollableSizableImage.EVENT_IMAGE_LOAD_COMPLETE, onLoadImageComplete);
				nodeImg.scaleToFit();
			}
			protected function onAddAnswer(e:Event = null):void
			{
				var newNode:Node = addNode(_node);
				addAnswerForNode(newNode, e);
			}
			public function addAnswerForNode(targetNode:Node, e:Event = null):void
			{
				_newNodes.push(targetNode);
				_node.data.addAnswer("", "0", {link:targetNode.id});
				//editQuestionDataGrid.lastAddedQuestion.options.link = newNode.id;
				//editQuestionDataGrid.lastAddedQuestion.answers[0].value = 0;
				var row:MultipleChoiceRow = new MultipleChoiceRow();
				row.popupInstance = this;
				row.rowIndex = mcList.numChildren;
				row.node = _node;
				//				row.letter = getNextLetter();
				row.destination = targetNode;
				mcList.addChildAt(row, mcList.numChildren);
				// Scroll Down
				scrollCanvas.invalidateDisplayList();
				trace("adding listener");
				listenForScrollUpdate(true);
				// Set focus
				if(e != null) row.answerField.setFocus();
				row.addEventListener(FocusEvent.FOCUS_IN, onRowFocusIn, false, 1, true);
				row.addEventListener(FocusEvent.FOCUS_OUT, onRowFocusOut, false, 0, true);
			}
			/**
			 * Waits for the scrollCanvas to dispatch UPDATE_COMPLETE event and
			 * calls "onScrollCanvasUpdate" which deals with positioning on several
			 * components.
			 */
			protected function listenForScrollUpdate(autoScrollDown:Boolean = false):void
			{
				// Set auto-scroll according to parameter
				_scrollDownPending = autoScrollDown;
				// Check if we already have a listener
				if(_scrollUpdatePending) return;
				// # Stop here if we do #
				// Add the listener
				_scrollUpdatePending = true;
				scrollCanvas.addEventListener(FlexEvent.UPDATE_COMPLETE, onScrollCanvasUpdate, false, 0, true);
			}
			protected function onScrollCanvasUpdate(e:Event):void
			{
				trace("PopupMc::onScrollCanvasUpdate");
				// Remove the listener that brought us here
				scrollCanvas.removeEventListener(FlexEvent.UPDATE_COMPLETE, onScrollCanvasUpdate);
				// Check if we're trying to auto-scroll down
				if(_scrollDownPending)
				{
					// Update scroll position if needed
					scrollCanvas.verticalScrollPosition = scrollCanvas.maxVerticalScrollPosition;
					// Show the delete button for the last item
					showDeleteButton(MultipleChoiceRow(mcList.getChildAt(mcList.numChildren - 1)));
					// Reset the auto-scroll flag
					_scrollDownPending = false
				}
				// Update the position of the delete button
				if(_deleteTarget != null)
				{
					// Find correct position for delete button
					var targetPoint:Point = deleteButton.parent.globalToLocal(scrollCanvas.localToGlobal(new Point(0, 0)));
	//				deleteButton.y = targetPoint.y - scrollCanvas.verticalScrollPosition + Math.min((_deleteTarget.rowIndex + 1 ) * (mcList.getStyle("verticalGap") + MultipleChoiceRow.rowHeight), scrollCanvas.height) + 1;
					deleteButton.y = targetPoint.y - scrollCanvas.verticalScrollPosition + (_deleteTarget.rowIndex + 1) * (mcList.getStyle("verticalGap") + MultipleChoiceRow.rowHeight);
					// Hide delete button if off-screen
					if(deleteButton.y > targetPoint.y + scrollCanvas.height + MultipleChoiceRow.rowHeight /2 || deleteButton.y < targetPoint.y + MultipleChoiceRow.rowHeight / 2) deleteButton.visible = false;
					else deleteButton.visible = true;
					trace("deleteY: " + (deleteButton.y - targetPoint.y));
				}
				// Put the add answer button where it needs to go
				trace("Add answer button being updated from: onScrollCanvasUpdate (PopupMc)");
				updateAddAnswerButton();
				// Reset the flag allowing more listeners to be added
				_scrollUpdatePending = false;
			}
			protected function onRowFocusOut(e:Event):void
			{
				trace("PopupMc::onRowFocusOut");
				hideDeleteButton();
			}
			protected function onRowFocusIn(e:Event):void
			{
				trace("PopupMc::onRowFocusIn");
				var row:MultipleChoiceRow = MultipleChoiceRow(e.currentTarget);
				showDeleteButton(row);
			}
			protected function showDeleteButton(row:MultipleChoiceRow):void
			{
				trace("PopupMC::showDeleteButton()");
				_deleteTarget = row;
				var position:Point = row.localToGlobal(new Point(0, 0));
				deleteButton.x = position.x - deleteButton.height;// + row.feedbackCanvas.x - deleteButton.width;
				deleteButton.y = position.y + deleteButton.width;// + row.height;
				deleteButton.visible = true;
				/* get reference to the node this answer row is pointing to */
				var childNode:Node = _node.children[row.rowIndex + rowOffset];

				/* if this row's target node has children OR the row is the only one remaining */
				if(deleteButton.enabled && (!childNode.isEmpty || childNode.children.length || (row.rowIndex == 0 && mcList.numChildren == 1)))
				{
					/* disable the delete button */
					deleteButton.enabled = false;
					deleteButton.transform.colorTransform = new ColorTransform(.7, .7, .7, .5, -0x44);

					if (!row.rowIndex && mcList.numChildren == 1)
					{
						ToolTip.add(deleteButton, "This node requires at least one answer!", {xOffset: -deleteButton.height / 2, yOffset: -deleteButton.height * 2});
					}
					else
					{
						ToolTip.add(deleteButton, "Only new/empty destinations can be deleted here. Please delete from tree view.", {xOffset: -deleteButton.height / 2, yOffset: -deleteButton.height * 2});
					}
				}
				/* otherwise, this row's target node node is "new" */
				else if(!deleteButton.enabled && childNode.isEmpty && row.rowIndex != 0)
				{
					/* enable the delete button */
					deleteButton.enabled = true;
					deleteButton.transform.colorTransform = new ColorTransform(1, 1, 1, 1);
					ToolTip.remove(deleteButton);
				}
			}
			protected function hideDeleteButton():void
			{
				_deleteTarget = null;
				deleteButton.visible = false;
			}
			protected function deleteRow(row:MultipleChoiceRow):Boolean
			{
				var rowIndex:int = row.rowIndex;
				var dataIndex:int = rowIndex + rowOffset;
				// Remove from tree and QSet
				var target:int = _node.data.answers[dataIndex].options.link;
				if(!_tree.attemptDeleteNode(_tree.getNodeFromId(target), false)) return false;
				// # Stop here if delete failed #
				// Remove from MC List
				MultipleChoiceRow(mcList.getChildAt(rowIndex)).destroy();
				mcList.removeChildAt(rowIndex);
				for(var i:int = rowIndex; i < mcList.numChildren; i++)
				{
					MultipleChoiceRow(mcList.getChildAt(i)).rowIndex--;
				}
				// Set focus to closest neighbor (preference towards bottom)
				if(mcList.numChildren)
				{
					MultipleChoiceRow(mcList.getChildAt(Math.min(rowIndex, mcList.numChildren - 1))).answerField.setFocus();
				}
				else
				{
					hideDeleteButton();
				}
				listenForScrollUpdate();
				// Get out of here!
				return true;
			}
			private function loadImage(event:MouseEvent):void
			{
				CreatorBase.openMediaScreen(onMediaLoaded);
			}
			private function onMediaLoaded(assetArr:Array):void
			{
				if(assetArr.length > 0)
				{
					_node.data.options.assetId = assetArr[0].id;
					updateImage(_node.data.options.assetId);
				}
			}
			private function updateQuestionColor():void
			{
				qField.setStyle("color", qField.text == DEFAULT_TEXT ? "#a5a5a5" : "#505050");
			}
			protected function getNextLetter():String
			{
				return String.fromCharCode(numQuestions++ + 65);
			}
			protected function addNode(parentNode:Node):Node
			{
				return _tree.addNode(parentNode, null).node;
			}

			public override function hide():void
			{
				if (!visible) return;
				onWindowClosed();
			}
		]]>
	</mx:Script>
	<components:AdventureButton id="changeImageButton" visible="false" anchored="true" label="Change Image" click="{loadImage(event);}" />
	<mx:VBox top="20" bottom="{20 + 40}" left="20" right="20">
		<!-- <mx:VBox top="20" left="20" right="20"> -->
		<mx:HBox id="contentHBox" width="100%" height="45%" paddingBottom="15">
			<mx:Canvas id="fieldCanvas" styleName="fieldCanvas" width="100%" height="100%"> <!-- Contains the Icon and Question -->
				<mx:HBox id="questionHBox" top="30" bottom="20" left="10" right="20">
					<mx:VBox height="100%" verticalGap="0" horizontalAlign="center">
						<components:DestinationBox id="nodeBox" minWidth="75" height="75"/>
					</mx:VBox>
					<mx:Spacer width="10" height="100%" />
					<mx:TextArea styleName="field" id="qField" text="{DEFAULT_TEXT}" width="100%" height="100%"
								 focusIn="{
								 	if(qField.text == DEFAULT_TEXT) {
								 		qField.text = '';
								 		updateQuestionColor();
								 	}
								 }"
								 focusOut="{
								 	if(!qField.text.length) {
								 		qField.text = DEFAULT_TEXT;
								 		updateQuestionColor();
								 	}
								 }"
					/>
					<!-- Image Container -->
					<mx:Canvas id="imageContainer" styleName="field" width="100%" height="100%" click="{loadImage(event);}" borderSkin="assets.DottedBorder">
						<components:AdventureImage id="nodeImg" width="100%" height="100%" />
					</mx:Canvas>
				</mx:HBox>
			</mx:Canvas> <!-- #fieldCanvas -->
			<!-- Add Image Button -->
			<components:AdventureButton id="addImageButton" usePlus="true" label="Add&#13;Image"
					   width="90" height="60" click="{setLayout(AdventureOptions.LAYOUT_HORIZ_TEXT)}"/>
			<mx:Canvas id="layoutsWindow" backgroundColor="0x7299b5" width="80" height="185">
				<mx:Label fontFamily="Arial MT Bold" fontSize="12" color="0xffffff" text="Layouts:" top="1" horizontalCenter="0" />
				<mx:VBox id="layoutButtons" backgroundColor="0xffffff" width="78" height="164" left="1" top="20"
						 verticalGap="4" horizontalAlign="center" verticalAlign="middle">
					<mx:Canvas id="layoutButton1" styleName="layoutCanvas" click="setLayout(AdventureOptions.LAYOUT_TEXT_ONLY)">
						<mx:Image source="@Embed(source='../assets/mcLayout1.png')" verticalCenter="0" horizontalCenter="0" />
						<mx:Container id="textOnlyOverlay" width="100%" height="100%" visible="false" backgroundColor="0x7299b5" alpha="0.09" />
					</mx:Canvas>
					<mx:Canvas id="layoutButton2" styleName="layoutCanvas" click="setLayout(AdventureOptions.LAYOUT_HORIZ_TEXT)">
						<mx:Image source="@Embed(source='../assets/narrativeLayout1.png')" verticalCenter="0" horizontalCenter="0" />
						<mx:Container id="layout2ButtonOverlay" width="100%" height="100%" visible="false" backgroundColor="0x7299b5" alpha="0.09" />
					</mx:Canvas>
					<mx:Canvas id="layoutButton3" styleName="layoutCanvas" click="setLayout(AdventureOptions.LAYOUT_HORIZ_IMAGE)">
						<mx:Image source="@Embed(source='../assets/narrativeLayout2.png')" verticalCenter="0" horizontalCenter="0" />
						<mx:Container id="layout3ButtonOverlay" width="100%" height="100%" visible="false" backgroundColor="0x7299b5" alpha="0.09" />
					</mx:Canvas>
				</mx:VBox>
				<mx:filters>
					<mx:DropShadowFilter color="#000000" distance="4" angle="90" blurX="8" blurY="6" alpha=".25" />
				</mx:filters>
			</mx:Canvas>
		</mx:HBox> <!-- #contentHBox -->
		<mx:VBox id="answerVBox" width="100%" height="55%">
			<mx:Label id="answerInstructions" text="Enter Possible Answers Below" styleName="heading" />
			<mx:Canvas id="headings" width="100%">
				<mx:Label left="0" color="0x222222" text="Possible Answers to Question:" />
				<mx:Label id="destinationHeaderLabel" color="0x222222" text="Destination:" />
				<mx:Label id="scoreHeaderLabel" right="44" color="0x222222" text="Score" />
			</mx:Canvas>
			<mx:VBox id="scrollCanvasContainer" width="100%" height="100%" verticalGap="0">
				<mx:Canvas id="scrollCanvas" width="100%" height="100%" verticalScrollPolicy="on" scroll="listenForScrollUpdate()">
					<mx:VBox id="mcList" styleName="mcList" width="100%" height="100%"/> <!-- Multiple Choice List -->
				</mx:Canvas>
			</mx:VBox>
			<mx:CheckBox id="randomizeBox" label="Randomize Order" selected="true" />
		</mx:VBox>
	</mx:VBox>
	<components:AdventureButton id="doneButton" bottom="10" right="20" label="Done" click="{hide();}" />
	<mx:Button id="deleteButton" visible="false" styleName="redButton" label="Delete" click="{deleteRow(_deleteTarget);}" paddingLeft="0" paddingRight="0" width="{MultipleChoiceRow.rowHeight}"/>
</screens:AdventurePopupBase>