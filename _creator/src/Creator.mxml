<?xml version="1.0" encoding="utf-8"?>
<materia:CreatorBase xmlns:mx="http://www.adobe.com/2006/mxml"
                     xmlns:materia="materia.*"
					 xmlns:components="materia.components.*"
                     width="100%" minHeight="450"
                     backgroundColor="#030304"
                     horizontalScrollPolicy="off" verticalScrollPolicy="off"
                     addedToStage="{onAddedToStage()}">
	<mx:Style source="/assets/adventure.css"/>
	<mx:Style source="/assets/materia/styles/style.css" />
	<mx:Style source="/assets/materia/styles/creatorStyle.css"/>
	<mx:Script> <![CDATA[
		import mx.controls.Alert;
		import components.ImportDisplayNode;
		import components.bubbles.HelperBubble;

		import materia.questionStorage.*;

		import screens.AdventurePopupBase;
		import screens.PopupEnd;
		import screens.PopupHotspot;
		import screens.PopupImport;
		import screens.PopupMc;
		import screens.PopupNarrative;
		import screens.PopupQType;
		import screens.PopupScoreType;
		import screens.PopupShortAnswer;

		import HelperBubbleManager;

		import tree.DisplayNode;
		import tree.DisplayTree;
		import tree.Node;
		public static const VERSION:String = "Alpha 1.3 Update 4b";
		public static const LINK_ID_START:int = 10000;
		public static const DEFAULT_ANSWER:String = "[No Answer]";
		private static const SCREEN_INTRO:int = 0;
		private static const SCREEN_TREE:int = 1;
		private static const DEFAULT_TITLE:String = "New Adventure Widget";
		private static const PADDING_H:int = 10;
		private static const PADDING_V:int = 10;
		//--------------------------------------------------------------------------
		//
		//  Variables
		//
		//--------------------------------------------------------------------------
		// private var _scoreStyle:int = AdventureOptions.SCORESTYLE_QUIZ;
		private var _adventureTree:DisplayTree;
		private var _selectedNode:Node;
		private var _activeScreen:AdventurePopupBase;
		private var _narrativeScreen:PopupNarrative;
		private var _mcScreen:PopupMc;
		private var _shortAnswerScreen:PopupShortAnswer;
		private var _hotSpotScreen:PopupHotspot;
		private var _endScreen:PopupEnd;
		private var _chooseTypeScreen:PopupQType;
		// private var _scoreStyleScreen:PopupScoreType;
		private var _importedScreen:PopupImport;
		private var _linkEditMode:Boolean = false;
		private var _currentScreen:AdventurePopupBase;
		private var time:Number;
		[Bindable]
		private var _undoDeleteButtonY:Number;
		private var _stage:EventDispatcher;

		public var helperManager:HelperBubbleManager;
		// private var _initialScore:int = 100;
		// [Bindable]
		// private var _scoreStyleLabel:String = "None Selected";
		//--------------------------------------------------------------------------
		//
		//  Accessor Functions
		//
		//--------------------------------------------------------------------------
		/*
		public function set scoreStyle(val:int):void
		{
			_scoreStyle = val;

			switch (val)
			{
				case 0:
					_scoreStyleLabel = AdventureOptions.SCORESTYLE_QUIZ_TEXT;
					break;
				case 1:
					_scoreStyleLabel = AdventureOptions.SCORESTYLE_QUEST_TEXT;
					break;
				case 2:
					_scoreStyleLabel = AdventureOptions.SCORESTYLE_DESTINATION_TEXT;
					break;
			}
		}
		public function get scoreStyle():int
		{
			return _scoreStyle;
		}
		*/
		/*
		public function set initialScore(val:int):void
		{
			_initialScore = val;
		}

		public function get initialScore():int
		{
			return _initialScore;
		}
		*/
		//--------------------------------------------------------------------------
		//
		//  Overridden methods
		//
		//--------------------------------------------------------------------------
		public override function init():void
		{
			super.init();
			// Keep track of time
			time = (new Date()).getTime();

			// initialize the helper bubble manager
			helperManager = new HelperBubbleManager();
			helperManager.initializeHelpers(this);

			// Create tree and editor popups
			createInterface();
			// update on resize
			this.addEventListener(Event.RESIZE, onResize, false, 0, true);
		}
		/**
		 *    Called when creating a new game (not called when editing)
		 */
		public override function initNewWidget(widget:Object, baseUrl:String):void
		{

			super.initNewWidget(widget, baseUrl);
			// create root node
			_selectedNode = addNode(null);

			instanceTitle = DEFAULT_TITLE;

			// Add the intro helper bubble
			helperManager.addHelper(helperManager.introBubble);

			// _scoreStyleScreen.show(this, _adventureTree.getNodeFromId(0));
		}
		/**
		 *    Called after init() when game is edited (loaded with a qset)
		 */
		protected override function initExistingWidget(title:String, widget:Object, qset:Object, version:String, baseUrl:String):void
		{
			super.initExistingWidget(title, widget, qset, version, baseUrl);
			// Load the score style (quiz|quest|free)
			// _scoreStyle = questionSet.items[0].options.scoreStyle;
			// Load the qset into the tree
			_adventureTree.createTreeFromQset(questionSet);
		}

		public override function startImportingSet():void
		{
			if (_importedScreen == null)
			{
				_importedScreen = new PopupImport();
				_importedScreen.addEventListener(ImportDisplayNode.EVENT_DRAG_BEGIN, onStartDragImport, false, 0, true);
				_importedScreen.addEventListener(ImportDisplayNode.EVENT_DRAG_END, onReleaseDragImport, false, 0, true);
				_importedScreen.addEventListener(PopupImport.EVENT_ALL_IMPORTS_PROCESSED, onAllImportsProcessed, false, 0, true);
			}
		}
		/**
		 *    Called once for each question that was selected to be imported.
		 */
		public override function addImportedQuestion(question:Question):Question
		{
			_importedScreen.addQuestion(question);
			return question;
		}
		public override function doneImportingSet():void
		{
			_importedScreen.show(this);
			importedButton.visible = true;
		}

		//--------------------------------------------------------------------------
		//
		//  Instance Methods
		//
		//--------------------------------------------------------------------------
		public function onAddedToStage():void
		{
			_stage = stage;
			_stage.addEventListener(KeyboardEvent.KEY_UP, onKeyUp);
		}
		public function testImporting():void
		{
			startImportingSet();
			//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			var questions:Vector.<Question> = new Vector.<Question>(10);
			var i:int = 0;
			questions[i] = new Question("MC", null, 0);
			questions[i].question = "Who was the first president of the United States?";
			questions[i].addAnswer("George Bush", "0");
			questions[i].addAnswer("Abraham Lincoln", "0");
			questions[i].addAnswer("George Washington", "100");
			i++;
			questions[i] = new Question("QA", null, 0);
			questions[i].question = "How many kilograms are in one pound";
			questions[i].addAnswer("0.45", "100");
			i++;
			//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			for each(var q:Question in questions)
			{
				addImportedQuestion(q);
			}
			doneImportingSet();
		}
		/**
		 * Called when a node is selected for editing. Brings up the
		 * appropriate editing interface (for question or hotspot)
		 * @param node The node to be edited
		 */
		public function editNode(node:Node):void
		{
			_selectedNode = node; // keep reference to selected node
			/* Load Edit Text Node Interface */
			switch (node.type)
			{
				case AdventureOptions.TYPE_MULTIPLE_CHOICE:
					_mcScreen.show(this, node);
					_activeScreen = _mcScreen;
					_adventureTree.redraw();
					break;
				case AdventureOptions.TYPE_HOTSPOT:
					_hotSpotScreen.show(this, node);
					_activeScreen = _hotSpotScreen;
					_adventureTree.redraw();
					break;
				case AdventureOptions.TYPE_END:
					_endScreen.show(this, node);
					_activeScreen = _endScreen;
					_adventureTree.redraw();
					break;
				case AdventureOptions.TYPE_SHORT_ANSWER:
					_shortAnswerScreen.show(this, node);
					_activeScreen = _shortAnswerScreen;
					_adventureTree.redraw();
					break;
				case AdventureOptions.TYPE_NARRATIVE:
					//addNode(node);
					_narrativeScreen.show(this, node);
					_activeScreen = _narrativeScreen;
					_adventureTree.redraw();
					break;
				default: // NONE
					_chooseTypeScreen.show(this, node);
			}
		}
		public function onResize(e:Event):void
		{
			if (_activeScreen != null && _activeScreen.visible == true)
			{
				PopUpManager.centerPopUp(_activeScreen);
			}
		}
		public function onDoneEditingLink():void
		{
			_currentScreen.onDoneEditingLink();
		}
		public function showUndoDelete():void
		{
			undoDeleteButton.visible = true;
		}
		public function hideUndoDelete():void
		{
			undoDeleteButton.visible = false;
		}
		/**
		 * Serves as an initializer for the interface. Creates the tree that
		 * will be used for viewing nodes as well as the windows that will
		 * be used to edit them.
		 */
		private function createInterface():void
		{
			_adventureTree = new DisplayTree(this);
			flashPanel.addChild(_adventureTree);
			/* Create instances of popups that will be reused (stay in memory) */
			_mcScreen = new PopupMc();
			_chooseTypeScreen = new PopupQType();
			// _scoreStyleScreen = new PopupScoreType();
			_hotSpotScreen = new PopupHotspot();
			_endScreen = new PopupEnd();
			_shortAnswerScreen = new PopupShortAnswer();
			_narrativeScreen = new PopupNarrative();
			// if you add a screen here, make sure to destroy it in AdventureCreator.onRemove()
			/* Add listeners to these popups */
			_mcScreen.addEventListener(DisplayNode.EVENT_FIND_LINK, onEditLink, false, 0, true);
			_shortAnswerScreen.addEventListener(DisplayNode.EVENT_FIND_LINK, onEditLink, false, 0, true);
			_narrativeScreen.addEventListener(DisplayNode.EVENT_FIND_LINK, onEditLink, false, 0, true);
			_hotSpotScreen.addEventListener(DisplayNode.EVENT_FIND_LINK, onEditLink, false, 0, true);
			_endScreen.addEventListener(DisplayNode.EVENT_FIND_LINK, onEditLink, false, 0, true);
		}
		private function onEditLink(e:DataEvent):void
		{
			e.stopPropagation();
			_currentScreen = AdventurePopupBase(e.currentTarget);
			_adventureTree.editLink(int(e.data), onDoneEditingLink);
		}
		private function onStartDragImport(e:Event):void
		{
			_adventureTree.beginImportMode();
			e.stopImmediatePropagation();
		}
		private function onReleaseDragImport(e:Event):void
		{
			var target:ImportDisplayNode = ImportDisplayNode(e.target);
			_adventureTree.attemptImport(target.node.data, onDragImportAccepted);
			e.stopImmediatePropagation();
		}
		private function onDragImportAccepted():void
		{
			_importedScreen.acceptImport();
		}
		private function onAllImportsProcessed(e:Event):void
		{
			importedButton.visible = false;
			_importedScreen.hide();
		}
		/**
		 * Adds a node to the adventure tree. Merely a helper function to
		 * access the addNode function inside of adventure tree
		 */
		private function addNode(parentNode:Node):Node
		{
			return _adventureTree.addNode(parentNode, null).node;
		}
		/**
		 *    Check to make sure we have valid info everywhere
		 *
		 *    <p>Will display an Alert with the errors found</p>
		 *
		 *    @return A value of <code>true</code> means there was an error;
		 *    A value of <code>false</code> means there is no error.
		 */
		private function checkForErrors():Boolean
		{
			// TODO: implement
			return false;
		}
		private function onKeyUp(e:KeyboardEvent):void
		{
			if (e.keyCode == Keyboard.ESCAPE)
			{
				// Cancel copy, link or undo mode
				var specialModeCanceled:Boolean = _adventureTree.cancelCurrentMode();
				// Close currently open popup if not in special mode
				if(!specialModeCanceled)
				{
					PopUpManager.removeFirstPopUp();
				}
			}
		}
		/*
		public function showInitialScoreBar():void
		{
			initialScoreBox.visible = true;
			initialScoreBox.height = 40;
		}

		public function hideInitialScoreBar():void
		{
			initialScoreBox.visible = false;
			initialScoreBox.height = 0;
		}
		*/
		/*
		private function updateInitialScore(val:Object):void
		{
			_initialScore = int(val);
		}
		*/
		public override function onSaveClicked(mode:String = 'save'):void
		{

			// Check for a valid items
			//if (_scoreStyle == AdventureOptions.SCORESTYLE_DESTINATION)
			//{
				if (mode == "publish" && !_adventureTree.validateEndNodes())
				{
					Alert.show("One or more question branches are missing an end point. With the Destination score style, every possible path must finish with an end point.","Can't publish quite yet...");
					ExternalInterface.call("__materia_flash_cancelSave");
					return;
				}
			//}

			// Build data to save
			var title:String = instanceTitle.length ? instanceTitle : DEFAULT_TITLE;
			var qSet:QuestionSet = new QuestionSet(title);
			var qGroup:QuestionGroup = _adventureTree.generateQGroup(title);
			// qGroup.options.scoreStyle = _scoreStyle;
			/*
			if (_scoreStyle == AdventureOptions.SCORESTYLE_QUEST)
			{
				qGroup.options.initialScore = _initialScore;
			}
			*/
			qSet.addGroup(qGroup);

			ExternalInterface.call("__materia_flash_save", title, qSet.convertToObject(), questionSetVersion);
		}

		]]>
</mx:Script>
	<mx:Parallel id="showTransition">
		<mx:Move yFrom="{ -undoDeleteButton.height - _undoDeleteButtonY }" yTo="{_undoDeleteButtonY}"/>
		<mx:Glow id="glow" color="#b6ff75" duration="1500" strength="2" blurXFrom="20" blurYFrom="20"/>
	</mx:Parallel>
	<mx:Move id="hideTransition" yFrom="{_undoDeleteButtonY}" yTo="{ -undoDeleteButton.height - _undoDeleteButtonY }"/>
	<mx:VBox top="0" bottom="0" left="0" right="0" verticalGap="0" height="100%">
		<mx:Canvas id="topBar" styleName="topBar" width="100%" height="48">
			<mx:HBox width="50%" height="100%" left="{PADDING_H}" verticalAlign="middle">
				<mx:Label text="Title: " styleName="sectionLabel"/>
				<mx:TextInput id="titleField" text="{instanceTitle}" change="{instanceTitle=titleField.text;}" height="38" width="100%" backgroundColor="#cfcfcf" color="#3f3f3f"
				              fontSize="24" cornerRadius="5" borderStyle="solid" borderColor="#e0e0e0"
				              borderThickness="1" paddingLeft="5" paddingRight="5"/>
			</mx:HBox>
			<mx:HBox right="{PADDING_H}" height="100%" verticalAlign="middle">
				<mx:Button id="undoDeleteButton" visible="false" label="Undo Delete"
				           click="{_adventureTree.restoreBackupTree();}" showEffect="{showTransition}"
				           hideEffect="hideTransition" creationComplete="{_undoDeleteButtonY = undoDeleteButton.y}"/>
				<mx:Button id="importedButton" label="Imported" visible="false"
				           click="{_importedScreen.visible ? _importedScreen.hide() : _importedScreen.show(this);}"/>
			</mx:HBox>
		</mx:Canvas>
		<!-- #topBar -->
		<mx:Canvas id="adventureArea" width="100%" height="100%" styleName="creatorSectionMajor">
			<mx:Canvas width="100%" height="100%" id="scrollCanvas" horizontalScrollPolicy="off"
			           backgroundColor="0xffffff">
				<mx:UIComponent id="flashPanel" width="100%" verticalCenter="0" horizontalCenter="0" top="0"/>
			</mx:Canvas>
			<mx:UIComponent id="flashOverlay" width="100%" height="100%" mouseEnabled="false"></mx:UIComponent>
		</mx:Canvas>
		<!-- adventureArea -->
	</mx:VBox>
</materia:CreatorBase>