package hotspots {
import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.EventDispatcher;
import flash.events.MouseEvent;
import flash.geom.ColorTransform;
import flash.geom.Point;
import flash.geom.Rectangle;
import AdventureOptions;
public class AdventureDisplayHotspot extends Sprite
{
	//--------------------------------------------------------------------------
	//
	//  Class constants
	//
	//--------------------------------------------------------------------------
	public static const EVENT_DRAG_END:String = "drag-end";
	public static const EVENT_DRAG_BEGIN:String = "drag-begin";
	public static const DEFAULT_COLOR_FILL:Number = 0x7799dd;
	public static const DEFAULT_STROKE:Number = 2;
	protected static const ANCHOR_SIZE:int = 10;
	protected static const ALPHA_FILL:Number = 0.28;
	protected static const ALPHA_STROKE:Number = 0.8;
	protected static const COLORTRANS_HIGHLIGHT:ColorTransform = new ColorTransform(.6, 1.5, 5, 2);
	protected static const COLORTRANS_NORMAL:ColorTransform = new ColorTransform(1, 1, 1, 1);
	//--------------------------------------------------------------------------
	//
	//  Instance Variables & Accessor Functions
	//
	//--------------------------------------------------------------------------
	protected var _color:Number = DEFAULT_COLOR_FILL;
	protected var stroke:Number = DEFAULT_STROKE;
	protected var _selected:Boolean = false;
	/**
	 * This hotspot's array position in its host array
	 */
	public var id:int;
	/**
	 * Used by the player (not creator) to keep track of link, name, feedback, etc
	 * Contains this hotspot's answers[i] data
	 */
	public var data:Object;
	/**
	 * The type of hotspot this is
	 */
	public var type:int;
	/**
	 * The image this hotspot belongs to (used as a reference for build points)
	 */
	public var targetImage:DisplayObject;
	/**
	 * Settings set by the object that owns this display hotspot
	 */
	public var settings:Object;
	/**
	 * If set to true, this hotspot will be invisible but still register clicks
	 */
	protected var _visibility:int = AdventureOptions.VISIBILITY_ALWAYS;
	/**
	 * If set to false, this hotspot will not be able to be dragged
	 */
	protected var _draggable:Boolean = true;
	protected var _container:Rectangle;
	/**
	 * True if this hotspot was dragged since last click
	 */
	public var dragging:Boolean = false;
	/**
	 * Keep track of whether we've added interation or not so we don't do it twice
	 */
	protected var hasInteraction:Boolean = false;
	public var resizing:Boolean = false;
	protected var resizeAnchors:Vector.<HotspotAnchor>;
	private var _stage:EventDispatcher;
	//--------------------------------------------------------------------------
	//
	//  Constructor
	//
	//--------------------------------------------------------------------------
	public function AdventureDisplayHotspot(targetImage:DisplayObject, draggable:Boolean, visibility:int)
	{
		super();
		this.targetImage = targetImage;
		_draggable = draggable;
		_visibility = visibility;
		// get a reference to the stage
		if(stage != null)
		{
			_stage = stage;
		}
		else
		{
			this.addEventListener(Event.ADDED_TO_STAGE, function t(event:Event):void {
				event.currentTarget.removeEventListener(event.type, arguments.callee);
				_stage = stage;
			}, false, 0, true);
		}
	}
	//--------------------------------------------------------------------------
	//
	//  Accessor Functions
	//
	//--------------------------------------------------------------------------
	public function get color():Number { return _color; }
	public function set color(val:Number):void { _color = val; updateAnchorColors(); }
	public function get selected():Boolean { return _selected; }
	public function set selected(val:Boolean):void
	{
		_selected = val;
		setHighlight(val);
		if(val) showAnchors();
		else hideAnchors();
	}
	//--------------------------------------------------------------------------
	//
	//  Instance Functions
	//
	//--------------------------------------------------------------------------
	/**
	 * Returns the points needed to reconstruct this hotspot.
	 */
	public function getPoints():Array { return null; }
	public function redraw():void { }
	/**
	 * Builds this hotspot from the given points (the points generated by getPoints())
	 */
	public function build(points:Array):void { }
	/**
	 * Draws the final version of the hotspot and prepares to save points
	 */
	public function finalize():void { }
	/**
	 * Removes any pending listeners
	 */
	public function destroy():void
	{
		this.removeEventListener(MouseEvent.MOUSE_OVER, onMouseOver);
		this.removeEventListener(MouseEvent.MOUSE_OUT, onMouseOut);
		this.removeEventListener(MouseEvent.MOUSE_UP, onMouseUp);
		this.removeEventListener(MouseEvent.MOUSE_DOWN, onMouseDown)
		this.removeEventListener(MouseEvent.MOUSE_MOVE, onMouseMoveDrag);
		_stage.removeEventListener(MouseEvent.MOUSE_UP, onMouseUp);
	}
//	public function changeTargetScale(oldScale:Number, newScale:Number):void
//	{
//		// Should be overriden
//	}
	public function getHotspot():AdventureHotspot
	{
		return new AdventureHotspot(type, getPoints());
	}
	public function calculateArea():Number
	{
		// Should be overriden
		return 0;
	}
	/**
	 * Adds listeners necessary to make this hotspot mouse-interactive
	 */
	protected function addInteraction():void
	{
		if(hasInteraction) return;
		hasInteraction = true;
		/* Highlight on Mouse Over */
		if(_visibility != AdventureOptions.VISIBILITY_NEVER)
		{
			this.addEventListener(MouseEvent.MOUSE_OVER, onMouseOver, false, 0, true);
			this.addEventListener(MouseEvent.MOUSE_OUT, onMouseOut, false, 0, true);
		}
		if(_visibility != AdventureOptions.VISIBILITY_ALWAYS)
		{
			this.alpha = 0;
		}
		if(resizeAnchors == null) buildAnchors();
		/* Enable Dragging */
		if(_draggable) this.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDown, false, 0, true);
	}
	/**
	 * Applies a highlight on mouse over
	 */
	protected function onMouseOver(e:Event):void
	{
		if(!_selected)
		{
			setHighlight(true);
		}
	}
	/**
	 * Removes highlight on mouse out
	 */
	protected function onMouseOut(e:Event):void
	{
		var alpha:Number = _visibility == AdventureOptions.VISIBILITY_ALWAYS ? 1 : 0;
		if(!_selected)
		{
			setHighlight(false);
		}
	}
	/**
	 * Start drag on mouse down
	 */
	protected function onMouseDown(e:Event):void
	{
		// avoid drag when creating a new hotspot
		if(settings != null && settings.creationInProgress) return;
		_container = new Rectangle(0, 0, parent.parent.width, parent.parent.height);
		var bounds:Rectangle = new Rectangle(0, 0, parent.parent.width - this.width, parent.parent.height - this.height);
		this.startDrag(false, bounds); // start drag on mouse down
		setHighlight(true);
		this.addEventListener(MouseEvent.MOUSE_UP, onMouseUp, false, 0, true);
		this.addEventListener(MouseEvent.MOUSE_MOVE, onMouseMoveDrag, false, 0, true);
		_stage.addEventListener(MouseEvent.MOUSE_UP, onMouseUp);
	}
	protected function onMouseMoveDrag(e:Event):void
	{
		this.removeEventListener(MouseEvent.MOUSE_MOVE, onMouseMoveDrag);
		if(!dragging) dispatchEvent(new Event(EVENT_DRAG_BEGIN));
		dragging = true;
	}
	/**
	 * Called when mouse is moved in the hotspot creation process.
	 * This function, when inherited, should actively redraw the hotspot.
	 */
	public function onMouseMoveCreate(e:MouseEvent):void { }
	protected function onMouseUp(e:Event):void
	{
		this.removeEventListener(MouseEvent.MOUSE_MOVE, onMouseMoveDrag);
		this.removeEventListener(MouseEvent.MOUSE_UP, onMouseUp);
		_stage.removeEventListener(MouseEvent.MOUSE_UP, onMouseUp);
		this.stopDrag(); // stop drag on mouse up
		/* If the hotspot was moved, tell listeners to update position reference */
		if(dragging) dispatchEvent(new Event(AdventureDisplayHotspot.EVENT_DRAG_END));
		dragging = false;
	}
	/**
	 * Adds or removes highlight on hotspot
	 */
	protected function setHighlight(val:Boolean):void
	{
		if(val)
		{
			this.transform.colorTransform = COLORTRANS_HIGHLIGHT;
		}
		else
		{
			this.transform.colorTransform = COLORTRANS_NORMAL;
		}
	}
	protected function getMousePoint():Point
	{
		var mouseX:Number = stage.mouseX;
		var mouseY:Number = stage.mouseY;
		/* find globalized defining points of container rect */
		var container:DisplayObject = parent.parent;
		var containerTL:Point = container.localToGlobal(new Point(0, 0));
		var containerBR:Point = container.localToGlobal(new Point(container.width, container.height));
		/* enforce boundaries */
		mouseX = Math.max(containerTL.x, Math.min(mouseX, containerBR.x));
		mouseY = Math.max(containerTL.y, Math.min(mouseY, containerBR.y));
		/* return result */
		return this.globalToLocal(new Point(mouseX, mouseY));
	}
	//----------------------------------
	//  Manage Resize Anchors
	//----------------------------------
	protected function buildAnchors():void { }
	protected function showAnchors():void
	{
		for each(var anchor:Sprite in resizeAnchors)
		{
			this.addChild(anchor);
			anchor.visible = true;
		}
		updateAnchorPositions();
	}
	protected function updateAnchorPositions():void { }
	protected function updateAnchorColors():void
	{
		for each(var anchor:HotspotAnchor in resizeAnchors)
		{
			anchor.color = this.color;
		}
	}
	protected function hideAnchors():void
	{
		for each(var anchor:Sprite in resizeAnchors) anchor.visible = false;
	}
	protected function onAnchorDragEnd(e:Event):void
	{
		finalize();
		updateAnchorPositions();
		resizing = false;
		dispatchEvent(new Event(AdventureDisplayHotspot.EVENT_DRAG_END));
	}
	protected function onAnchorDragged(e:Event):void
	{
		if(!resizing) dispatchEvent(new Event(AdventureDisplayHotspot.EVENT_DRAG_BEGIN));
		resizing = true;
	}
}
}